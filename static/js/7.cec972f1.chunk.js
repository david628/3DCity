(this["webpackJsonpfar-seer"]=this["webpackJsonpfar-seer"]||[]).push([[7],{139:function(e,t,r){"use strict";var n=r(44),o={radius:{RADIUS:6378137}.RADIUS,normalizeVector:function(e){var t,r;return 4===e.length?(t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],r=Math.sqrt(t),e[0]=0!==e[0]?e[0]/r:0,e[1]=0!==e[1]?e[1]/r:0,e[2]=0!==e[2]?e[2]/r:0,e[3]=0!==e[3]?e[2]/r:0):(t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],r=Math.sqrt(t),e[0]=0!==e[0]?e[0]/r:0,e[1]=0!==e[1]?e[1]/r:0,e[2]=0!==e[2]?e[2]/r:0),e},sub:function(e,t,r){return null!==r&&void 0!==r||(r=[0,0,0]),r[0]=e[0]-t[0],r[1]=e[1]-t[1],r[2]=e[2]-t[2],r},subtractVectors:function(e,t,r){return e.isVector3&&(e=[e.x,e.y,e.z]),t.isVector3&&(t=[t.x,t.y,t.z]),this.sub(e,t,r)},lonlatToWorldHeight:function(e,t){var r=e[0],n=e[1],o=r/180*Math.PI,a=n/180*Math.PI;null!==t&&void 0!==t||(t=0);var i=t*Math.cos(a),s=t*Math.sin(a);return[-i*Math.cos(o),s,i*Math.sin(o)]},lonLatToWorld:function(e,t){return this.lonlatToWorldHeight(e,this.radius+(t||0))},worldToLonLat:function(e,t){var r=t;r||(r=[0,0,0]);var n=this.subtractVectors(e,r),o=n[1],a=n[2],i=[n[0],0,n[2]];n=this.normalizeVector(n),i=this.normalizeVector(i);var s=180-this.getAngleBetweenVectors(i,[1,0,0]),l=this.getAngleBetweenVectors(i,n);return a<0&&(s=-s),o<0&&(l=-l),[s,l,this.vectorDistance(e,r)-this.radius]},lonLatToWebMercator:function(e){return this.lonLatToMercator(e)},lonLatToMercator:function(e){var t=20037508.34*e[0]/180,r=Math.log(Math.tan((90+e[1])*Math.PI/360))/(Math.PI/180);return(r=20037508.34*r/180)>20037508.34&&(r=20037508.34),r<-20037508.34&&(r=-20037508.34),[t,r]},arrayToFloat32Array:function(e){for(var t=e.length,r=new Float32Array(t),n=0;n<t;n++)r[n]=e[n];return r},getDistanceFromArray:function(e,t){return Math.sqrt((e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1]))},cross:function(e,t,r){return null!==r&&void 0!==r||(r=[0,0,0]),r[0]=e[1]*t[2]-e[2]*t[1],r[1]=e[2]*t[0]-e[0]*t[2],r[2]=e[0]*t[1]-e[1]*t[0],r},dot:function(e,t){return e.x*t.x+e.y*t.y+e.z*t.z},vectorDotProduct:function(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]},vectorDistance:function(e,t){var r=this.subtractVectors(e,t);return this.vectorLength(r)},vectorLength:function(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2])},vectorCrossProduct:function(e,t,r){return this.cross(e,t,r)},radiansToDegrees:function(e){return e/(2*Math.PI)*360},getAngleBetweenVectors:function(e,t){var r=this.vectorDotProduct(e,t);return this.radiansToDegrees(Math.acos(r))},getCenterCoord:function(e){for(var t=0,r=0,n=0;n<e.length;n++)t+=e[n][0],r+=e[n][1];return[t/=e.length,r/=e.length]},isVisible:function(e){return!!(1&e.layers.mask)},setVisible:function(e,t){t?e.layers.enable(0):e.layers.disable(0)},visible:function(e,t){var r=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(void 0===t){if(e.userData.useVisibleOnly)return e.visible;for(var n=e;n;n=n.parent)if(!n.visible)return!1;return this.isVisible(e)}if("boolean"!==typeof t){var o=e.userData;if(!o.alwaysPickable)for(var a=e;a;){if(!a.visible)return!1;if(t&&!a.layers.test(t.layers))return!1;a=a.parent}return!0}var i=t;e.userData.useVisibleOnly?e.visible=i:(this.setVisible(e,i),r&&(e.visible=i))},setPosition:function(e,t){var r=new n.Vector3(0,0,0);Array.isArray(t)?r.set(t[0],t[1],t[2]):t.isVector3?r=t.clone():r.set(t.x,t.y,t.z),e.position.copy(r),(e.parent||e).updateMatrixWorld()},setDirection:function(e,t,r){var o=new n.Vector3,a=new n.Vector3(t[0],t[1],t[2]);e.getWorldDirection(o),o.set(r[0],r[1],r[2]);var i=e.worldToLocal(a),s=e.worldToLocal(new n.Vector3(0,0,0)),l=i.sub(s);l.normalize();var c=new n.Quaternion;c.setFromUnitVectors(o,l),c.normalize(),e.setRotationFromQuaternion(c),e.updateMatrixWorld()},worldToLocal:function(e,t){var r;r=t.isVector3?t.clone():new n.Vector3(t[0],t[1],t[2]);var o=e.worldToLocal(r);return[o.x,o.y,o.z]},transPosition:function(e,t,r){var o=new n.Vector3(e[0],e[1],e[2]).project(r),a=(t.innerWidth||t.offsetWidth)/2,i=(t.innerHeight||t.offsetHeight)/2;return{x:Math.round(o.x*a+a),y:Math.round(-o.y*i+i)}},getColor:function(e){if(-1!==e.indexOf("rgba")||-1!==e.indexOf("rgb")){var t=e.indexOf("("),r=e.substring(t+1,e.length-1).split(",");return[Number(r[0].trim())/255,Number(r[1].trim())/255,Number(r[2].trim())/255]}return[255,255,255]}};t.a=o},162:function(e,t,r){"use strict";r.r(t),r.d(t,"default",(function(){return i}));var n=r(58),o=r(19),a=r(20),i=function(){function e(t){Object(o.a)(this,e)}return Object(a.a)(e,[{key:"init",value:function(){}},{key:"clear",value:function(){var e;(e=this.node).remove.apply(e,Object(n.a)(this.node.children))}},{key:"updateEffect",value:function(e,t,r){var n=t.name,o=t.value;r?window.THREEx.EffectManager.add(e,n,o):window.THREEx.EffectManager.remove(e,n)}}]),e}()},188:function(e,t,r){"use strict";var n={toGeometry:function(e,t){var r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],o=arguments.length>4?arguments[4]:void 0,a=e.type;if("FeatureCollection"===a)for(var i=0;i<e.features.length;i++)this.toGeometry(e.features[i],t,r,n,e.features[i].properties);else if("Feature"===a)this.toGeometry(e.geometry,t,r,n,e.properties);else if("GeometryCollection"===a)for(var s=0;s<e.geometries.length;s++)this.toGeometry(e.geometries[s],t,r,n,o);else if("MultiPolygon"===a){for(var l=0;l<e.coordinates.length;l++)this.rewindRings(e.coordinates[l],r);var c={type:"MultiPolygon"};c.coordinates=e.coordinates,c.properties=o,n.push(c),t&&t(c)}else if("Polygon"===a){this.rewindRings(e.coordinates,r);var u={type:"Polygon"};u.coordinates=e.coordinates,u.properties=o,n.push(u),t&&t(u)}else if("MultiLineString"===a){var h={type:"MultiLineString"};h.coordinates=e.coordinates,h.properties=o,n.push(h),t&&t(h)}else if("LineString"===a){var f={type:"LineString"};f.coordinates=e.coordinates,f.properties=o,n.push(f),t&&t(f)}else if("MultiPoint"===a){var d={type:"MultiPoint"};d.coordinates=e.coordinates,d.properties=o,n.push(d),t&&t(d)}else if("Point"===a){var m={type:"Point"};m.coordinates=e.coordinates,m.properties=o,n.push(m),t&&t(m)}return n},rewindRings:function(e,t){if(!(e.length<=0)){this.rewindRing(e[0],t);for(var r=1;r<e.length;r++)this.rewindRing(e[r],t)}},rewindRing:function(e,t){for(var r=0,n=1/0,o=-1/0,a=1/0,i=-1/0,s=0,l=e.length,c=l-1;s<l;c=s++)e[s][0]>o&&(o=e[s][0]),e[s][0]<n&&(n=e[s][0]),e[s][1]>i&&(i=e[s][1]),e[s][1]<a&&(a=e[s][1]),r+=(e[s][0]-e[c][0])*(e[s][1]+e[c][1]);r>=0!==!!t&&e.reverse()}};t.a=n},326:function(e,t,r){"use strict";var n=r(44),o={init:function(){this.cacheList=n._____Cache={}},save:function(e,t,r){this.cacheList[e]||(this.cacheList[e]=new Map),this.cacheList[e].set(t,r)},get:function(e,t){return this.cacheList[e]?this.cacheList[e].get(t):null},delete:function(e,t){this.cacheList[e]&&this.cacheList[e].delete(t)},getAll:function(e){return this.cacheList[e]?this.cacheList[e]:null}};t.a=o},327:function(e,t){e.exports="precision highp float;\r\nvarying vec2 texCoords;\r\nvarying vec3 PositionWS;\r\n//varying vec3 ModelPostion;\r\nvarying float v_distance;\r\nuniform vec4 objectPos;\r\n#include <shadowmap_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#ifdef QUANTIZATION_BITS12\r\n    uniform mat4 u_scaleAndBias;\r\n#endif\r\n#include <common>\r\n\r\n//\u4e4b\u524d\u7684\u903b\u8f91\u6709\u95ee\u9898\uff0c\u5927\u5c3a\u5ea6\u4e0b\u9700\u8981\u65f6\u523b\u601d\u8003\u7cbe\u5ea6\u95ee\u9898\r\nvec3 czm_decodePos(vec3 encoded, mat4 fromScaledENU, vec4 pos) {\r\n    float temp = encoded.x / 4096.0;\r\n    float temp_x = floor(temp) /4096.0;\r\n    float temp_y =temp - floor(temp);\r\n    float temp_z = encoded.y / 4096.0;\r\n    temp_z = floor(temp_z) / 4096.0;\r\n    vec4 temp_result = vec4(temp_x, temp_y, temp_z,1.0);\r\n    vec4 o_pos = fromScaledENU*temp_result;\r\n    vec3 final = o_pos.xyz;\r\n    return final;\r\n}\r\nvec2 czm_decodeUv(vec3 encoded) {\r\n    float tempuv = encoded.z / 4096.0;\r\n    float u = floor(tempuv) / 4096.0;\r\n    float v = tempuv - floor(tempuv);\r\n    return vec2(u,v);\r\n }\r\nvoid main() {\r\n    vec3 czm_position = vec3(0.0);\r\n    vec2 textureCoordinates = vec2(0.0);\r\n     #ifdef QUANTIZATION_BITS12\r\n        czm_position = czm_decodePos(position, u_scaleAndBias, objectPos);\r\n        textureCoordinates = czm_decodeUv(position);\r\n        //czm_position = position;\r\n    #else\r\n        czm_position = position;\r\n        textureCoordinates = uv;\r\n    #endif\r\n        //czm_position = czm_converPosition(czm_position);\r\n        vec4 worldPosition = modelMatrix * vec4( czm_position, 1.0 );\r\n        PositionWS =  czm_position.xyz + objectPos.xyz;\r\n        v_distance = length((modelViewMatrix * vec4(czm_position.xyz, 1.0)).xyz);\r\n        texCoords = textureCoordinates;\r\n\r\n\tvec4 mvPosition = modelViewMatrix * vec4( czm_position, 1.0 );\r\n    #include <shadowmap_vertex>\r\n    #include <fog_vertex>\r\n    gl_Position = projectionMatrix * mvPosition;\r\n    #include <logdepthbuf_vertex>\r\n}"},438:function(e,t,r){"use strict";r.d(t,"a",(function(){return o})),r.d(t,"b",(function(){return a}));var n=r(44),o=function(e){n.Object3D.call(this),this.element=e||document.createElement("div"),this.element.style.position="absolute",this.addEventListener("removed",(function(){this.traverse((function(e){e.element instanceof Element&&null!==e.element.parentNode&&e.element.parentNode.removeChild(e.element)}))}))};o.prototype=Object.assign(Object.create(n.Object3D.prototype),{constructor:o,copy:function(e,t){return n.Object3D.prototype.copy.call(this,e,t),this.element=e.element.cloneNode(!0),this}});var a=function(){var e,t,r,a,i=this,s=new n.Vector3,l=new n.Matrix4,c=new n.Matrix4,u={objects:new WeakMap},h=document.createElement("div");h.style.overflow="hidden",this.domElement=h,this.getSize=function(){return{width:e,height:t}},this.setSize=function(n,o){r=(e=n)/2,a=(t=o)/2,h.style.width=n+"px",h.style.height=o+"px"};var f=function e(t,n,l){if(t instanceof o){t.onBeforeRender(i,n,l),s.setFromMatrixPosition(t.matrixWorld),s.applyMatrix4(c);var f=t.element,m="translate(-50%,-50%) translate("+(s.x*r+r)+"px,"+(-s.y*a+a)+"px)";f.style.WebkitTransform=m,f.style.MozTransform=m,f.style.oTransform=m,f.style.transform=m,f.style.display=t.visible&&s.z>=-1&&s.z<=1?"":"none";var v={distanceToCameraSquared:d(l,t)};u.objects.set(t,v),f.parentNode!==h&&h.appendChild(f),t.onAfterRender(i,n,l)}for(var p=0,g=t.children.length;p<g;p++)e(t.children[p],n,l)},d=function(){var e=new n.Vector3,t=new n.Vector3;return function(r,n){return e.setFromMatrixPosition(r.matrixWorld),t.setFromMatrixPosition(n.matrixWorld),e.distanceToSquared(t)}}(),m=function(e){for(var t=function(e){var t=[];return e.traverse((function(e){e instanceof o&&t.push(e)})),t}(e).sort((function(e,t){return u.objects.get(e).distanceToCameraSquared-u.objects.get(t).distanceToCameraSquared})),r=t.length,n=0,a=t.length;n<a;n++)t[n].element.style.zIndex=r-n};this.render=function(e,t){!0===e.autoUpdate&&e.updateMatrixWorld(),null===t.parent&&t.updateMatrixWorld(),l.copy(t.matrixWorldInverse),c.multiplyMatrices(t.projectionMatrix,l),f(e,e,t),m(e)}}},439:function(e,t,r){"use strict";r.r(t),r.d(t,"default",(function(){return f}));var n=r(19),o=r(20),a=r(23),i=r(21),s=r(22),l=r(44),c=r(162),u=r(139),h=r(188),f=function(e){Object(i.a)(r,e);var t=Object(s.a)(r);function r(e){var o;return Object(n.a)(this,r),(o=t.call(this)).effect=!1,o.topColor=5075844,o.sideColor=6726638,o.height=100,o.buildingTextureSize=[20,20],o.buildingMaskTextureSize=[60,60],Object.assign(Object(a.a)(o),e),o.init(),o}return Object(o.a)(r,[{key:"init",value:function(){var e=new l.MeshStandardMaterial({color:this.topColor,side:l.BackSide,transparent:!0,opacity:1}),t=new l.MeshStandardMaterial({color:this.sideColor,side:l.BackSide,transparent:!0,opacity:1});this.material=[e,t]}},{key:"geoJSON",value:function(e){var t=this;h.a.toGeometry(e,(function(e){"MultiPolygon"!==e.type&&"Polygon"!==e.type||t.createMesh("Polygon"===e.type?[e.coordinates]:e.coordinates,{height:void 0!==e.properties.height&&null!==e.properties.height?e.properties.height:t.height})}))}},{key:"setData",value:function(e){this.clear(),this.geoJSON(e),this.setStyle(this.style)}},{key:"createMesh",value:function(e,t){var r=this,n=this.buildingTextureSize,o=this.buildingMaskTextureSize,a=this.height;a=t.height;var i=new l.Group;this.node.add(i);var s=e,c=u.a.getCenterCoord(s[0][0]),h=u.a.lonLatToWorld(c);u.a.setPosition(i,h),u.a.setDirection(i,h,[0,1,0]);for(var f=function(e){for(var t=s[e],c=[],h=0;h<t.length;h++)if(0===h)for(var f=0;f<t[h].length;f++){var d=u.a.worldToLocal(i,u.a.lonLatToWorld(t[h][f]));d=new l.Vector3(d[0],d[2],d[1]),c.push(d)}var m=new l.Shape(c),v=new l.BufferGeometry;v.topUV=[],v.sideUV1=[],v.sideUV2=[],v.sideUV3=[],v.sideUV4=[],v.sideUV5=[],v.sideUV6=[],v.sideUV7=[],null===v.boundingBox&&(v.boundingBox=new l.Box3),v.boundingBox.setFromPoints(c);for(var p={generateTopUV:function(e,t,r,n,o){var a=(t[3*r]-v.boundingBox.min.x)/(v.boundingBox.max.x-v.boundingBox.min.x),i=1-(t[3*r+1]-v.boundingBox.min.y)/(v.boundingBox.max.y-v.boundingBox.min.y),s=(t[3*n]-v.boundingBox.min.x)/(v.boundingBox.max.x-v.boundingBox.min.x),c=1-(t[3*n+1]-v.boundingBox.min.y)/(v.boundingBox.max.y-v.boundingBox.min.y),u=(t[3*o]-v.boundingBox.min.x)/(v.boundingBox.max.x-v.boundingBox.min.x),h=1-(t[3*o+1]-v.boundingBox.min.y)/(v.boundingBox.max.y-v.boundingBox.min.y),f=[new l.Vector2(a,i),new l.Vector2(s,c),new l.Vector2(u,h)];return v.topUV.push.call(v.topUV,f[0].x,f[0].y,f[1].x,f[1].y,f[2].x,f[2].y),f},generateSideWallUV:function(e,t,r,i){var s=[t[3*r],t[3*r+1]],c=[t[3*i],t[3*i+1]],h=u.a.getDistanceFromArray(s,c)/n[0],f=a/n[1],d=u.a.getDistanceFromArray(s,c)/o[0],m=a/o[1],p=function(e,t,r){var n=[new l.Vector2(0,0),new l.Vector2(e,0),new l.Vector2(e,t),new l.Vector2(0,t)];r.push.call(r,n[0].x,n[0].y,n[1].x,n[1].y,n[3].x,n[3].y),r.push.call(r,n[1].x,n[1].y,n[2].x,n[2].y,n[3].x,n[3].y)},g=[new l.Vector2(0,0),new l.Vector2(1,0),new l.Vector2(1,1),new l.Vector2(0,1)];return p(-1,1,v.sideUV1),p(-1,f,v.sideUV2),p(-h,1,v.sideUV3),p(-h,f,v.sideUV4),p(-1,m,v.sideUV5),p(-d,1,v.sideUV6),p(-d,m,v.sideUV7),g}},g=new l.ExtrudeBufferGeometry(m,{steps:1,depth:a,material:0,extrudeMaterial:1,bevelEnabled:!1,UVGenerator:p}),y=g.attributes.normal.array,C=g.attributes.position.array,x=0;x<C.length;x+=3){var b=C[x+1];C[x+1]=C[x+2],C[x+2]=b,y[x]=-y[x],y[x+1]=-y[x+1],y[x+2]=-y[x+2];var w=y[x+1];y[x+1]=y[x+2],y[x+2]=w}g.topUV=v.topUV,g.sideUV1=v.sideUV1,g.sideUV2=v.sideUV2,g.sideUV3=v.sideUV3,g.sideUV4=v.sideUV4,g.sideUV5=v.sideUV5,g.sideUV6=v.sideUV6,g.sideUV7=v.sideUV7,g.setAttribute("uv2",new l.BufferAttribute(u.a.arrayToFloat32Array(v.topUV.concat(v.sideUV1)),2)),g.attributes.uv.needsUpdate=!0;var S=new l.Mesh(g,r.material);i.add(S)},d=0;d<s.length;d++)f(d)}},{key:"setStyle",value:function(e){var t=e.topImg,r=e.topColor,n=e.topOpacity,o=e.sideImg,a=e.sideColor,i=e.sideOpacity,s=e.height,c=e.effect;if(this.material[0].map=t?this.view.textureLoader.load(t,(function(e){return e.wrapS=l.RepeatWrapping,e.wrapT=l.RepeatWrapping,e.anisotropy=16,e.needsUpdate=!0,e})):this.view.textureLoader.load("images/s.png",(function(e){return e.wrapS=l.RepeatWrapping,e.wrapT=l.RepeatWrapping,e.anisotropy=16,e.needsUpdate=!0,e})),void 0!==r&&this.material[0].color.set(r),void 0!==n&&(this.material[0].opacity=n),this.material[1].map=o?this.view.textureLoader.load(o,(function(e){return e.wrapS=l.RepeatWrapping,e.wrapT=l.RepeatWrapping,e.anisotropy=16,e.needsUpdate=!0,e})):this.view.textureLoader.load("images/s.png",(function(e){return e.wrapS=l.RepeatWrapping,e.wrapT=l.RepeatWrapping,e.anisotropy=16,e.needsUpdate=!0,e})),void 0!==a&&this.material[1].color.set(a),void 0!==i&&(this.material[1].opacity=i),void 0!==s){void 0!==this.preHeight&&null!==this.preHeight||(this.preHeight=s);var u=s/this.preHeight;this.node.children.forEach((function(e){e.scale.y=u||1}))}this.setEffect(c)}},{key:"setEffect",value:function(e){for(var t=0;t<this.node.children.length;t++)for(var r=0;r<this.node.children[t].children.length;r++)this.updateEffect(this.node.children[t].children[r],{name:"urealBloom",value:.3},e)}}]),r}(c.default)},440:function(e,t,r){"use strict";r.r(t),r.d(t,"default",(function(){return d}));var n=r(19),o=r(20),a=r(23),i=r(21),s=r(22),l=r(44),c=r(162),u=r(139),h=r(188),f=r(438),d=function(e){Object(i.a)(r,e);var t=Object(s.a)(r);function r(e){var o;return Object(n.a)(this,r),(o=t.call(this)).style={fontColor:"#ffffff",fontSize:12,color:"rgba(10,18,51,0.8)",opacity:1,lineColor:"#ffffff",lineOpacity:1},Object.assign(Object(a.a)(o),e),o.init(),o}return Object(o.a)(r,[{key:"init",value:function(){this.lineMaterial=new l.PointsMaterial({color:16777215,transparent:!0})}},{key:"geoJSON",value:function(e){var t=this;h.a.toGeometry(e,(function(e){"MultiPoint"!==e.type&&"Point"!==e.type||t.createMesh("Point"===e.type?[e.coordinates]:e.coordinates,{height:void 0!==e.properties.height&&null!==e.properties.height?e.properties.height:t.height})}))}},{key:"getSpriteTexture",value:function(e){var t;return(t=this.view.textureLoader.load("images/earth/icon/24.png")).needsUpdate=!0,t}},{key:"setData",value:function(e){this.clear(),this.doms=[];for(var t=0;t<e.length;t++){var r=u.a.lonLatToWorld([e[t].lng,e[t].lat]),n=u.a.lonLatToWorld([e[t].lng,e[t].lat],200),o=document.createElement("div");o.style="padding: 5px;border-radius: 4px;background-color: rgba(10,18,51,.8);",o.innerHTML='\n                    <div style="width: 30px;height: 30px;float: left;">\n                        <img src="'.concat(e[t].iconUrl,'" style="width: 100%;height: 100%;"/>\n                    </div>\n                    <div style="overflow: hidden;padding: 4px 8px;">').concat(e[t].content,"</div>\n                ");var a=new f.a(o);a.position.x=n[0],a.position.y=n[1],a.position.z=n[2];var i=new l.BufferGeometry,s=new Float32Array(6);s[0]=r[0],s[1]=r[1],s[2]=r[2],s[3]=n[0],s[4]=n[1],s[5]=n[2],i.setAttribute("position",new l.BufferAttribute(s,3));var c=new l.Line(i,this.lineMaterial);this.node.add(c),this.node.add(a),this.doms.push(o)}this.setStyle(this.style)}},{key:"createMesh",value:function(e,t){}},{key:"setStyle",value:function(e){for(var t=e.fontColor,r=e.color,n=e.opacity,o=e.fontSize,a=e.lineColor,i=e.lineOpacity,s=0;s<this.doms.length;s++)this.doms[s].style.backgroundColor=r,this.doms[s].style.opacity=n,this.doms[s].style.fontSize=o+"px",this.doms[s].style.color=t;void 0!==a&&this.lineMaterial.color.set(a),void 0!==i&&(this.lineMaterial.opacity=i)}}]),r}(c.default)},441:function(e,t,r){"use strict";r.r(t),r.d(t,"default",(function(){return f}));var n=r(19),o=r(20),a=r(23),i=r(21),s=r(22),l=r(44),c=r(162),u=r(139),h=r(188),f=function(e){Object(i.a)(r,e);var t=Object(s.a)(r);function r(e){var o;return Object(n.a)(this,r),(o=t.call(this)).style={speed:.02,width:5,color:"#ffc627",opacity:1,imageUrl:"images/path/path.png",effect:!0},Object.assign(Object(a.a)(o),e),o.init(),o}return Object(o.a)(r,[{key:"init",value:function(){var e=this.view.textureLoader.load(this.style.imageUrl);e.wrapS=l.RepeatWrapping;var t=new l.MeshBasicMaterial({color:this.style.color,map:e,transparent:!0,depthWrite:!1,opacity:this.opacity});this.material=t}},{key:"geoJSON",value:function(e){var t=this;h.a.toGeometry(e,(function(e){"MultiLineString"!==e.type&&"LineString"!==e.type||t.createMesh("LineString"===e.type?[e.coordinates]:e.coordinates)}))}},{key:"setData",value:function(e){this.clear(),this.geoJSON(e),this.setStyle(this.style)}},{key:"createMesh",value:function(e){for(var t=0;t<e.length;t++){for(var r=e[t],n=[],o=0;o<r.length;o++){var a=u.a.lonLatToWorld(r[o]);n.push(new l.Vector3(a[0],a[1],a[2]))}var i=new l.CatmullRomCurve3(n),s=new l.TubeBufferGeometry(i,64,this.style.width,8,!1);s.attributes.uv.needsUpdate=!0;var c=new l.Mesh(s,this.material);this.node.add(c)}}},{key:"setStyle",value:function(e){var t=e.color,r=e.img,n=e.opacity,o=e.speed,a=e.direction,i=e.effect;this.material.map=r?this.view.textureLoader.load(r,(function(e){return e.wrapS=l.RepeatWrapping,e.wrapT=l.RepeatWrapping,e.anisotropy=16,e.needsUpdate=!0,e})):this.view.textureLoader.load("images/path/path.png",(function(e){return e.wrapS=l.RepeatWrapping,e.wrapT=l.RepeatWrapping,e.anisotropy=16,e.needsUpdate=!0,e})),void 0!==t&&this.material.color.set(t),void 0!==n&&(this.material.opacity=n),void 0!==a&&(this.style.direction=a),void 0!==o&&(this.style.speed=o),this.setEffect(i)}},{key:"setEffect",value:function(e){for(var t=0;t<this.node.children.length;t++)this.updateEffect(this.node.children[t],{name:"urealBloom",value:1},e)}},{key:"updateColor",value:function(e){this.material.color.setHex(e)}},{key:"updateOpacity",value:function(e){this.material.opacity=e}},{key:"update",value:function(){this.material.map&&(this.style.direction?this.material.map.offset.x-=this.style.speed:this.material.map.offset.x+=this.style.speed)}}]),r}(c.default)},442:function(e,t,r){"use strict";r.r(t),r.d(t,"default",(function(){return f}));var n=r(19),o=r(20),a=r(23),i=r(21),s=r(22),l=r(44),c=r(162),u=r(139),h=r(188),f=function(e){Object(i.a)(r,e);var t=Object(s.a)(r);function r(e){var o;return Object(n.a)(this,r),(o=t.call(this)).style={img:"images/point/1.png",color:"#00ff00",opacity:1,size:300,lineColor:"#ffffff",lineOpacity:1},Object.assign(Object(a.a)(o),e),o.init(),o}return Object(o.a)(r,[{key:"init",value:function(){this.material=new l.PointsMaterial({size:this.style.size,transparent:!0,blending:l.AdditiveBlending,depthTest:!0,depthWrite:!1}),this.lineMaterial=new l.PointsMaterial({transparent:!0})}},{key:"geoJSON",value:function(e){var t=this;h.a.toGeometry(e,(function(e){"MultiPoint"!==e.type&&"Point"!==e.type||t.createMesh("Point"===e.type?[e.coordinates]:e.coordinates,{height:void 0!==e.properties.height&&null!==e.properties.height?e.properties.height:t.height})}))}},{key:"setData",value:function(e){this.clear();for(var t=new l.BufferGeometry,r=new Float32Array(3*e.length),n=0;n<e.length;n++){var o=u.a.lonLatToWorld([e[n].lng,e[n].lat]),a=u.a.lonLatToWorld([e[n].lng,e[n].lat],150);r[3*n]=a[0],r[3*n+1]=a[1],r[3*n+2]=a[2];var i=new Float32Array(6);i[0]=o[0],i[1]=o[1],i[2]=o[2],i[3]=a[0],i[4]=a[1],i[5]=a[2];var s=new l.BufferGeometry;s.setAttribute("position",new l.BufferAttribute(i,3));var c=new l.Line(s,this.lineMaterial);this.node.add(c)}t.setAttribute("position",new l.BufferAttribute(r,3));var h=new l.Points(t,this.material);h.sortParticles=!0,this.node.add(h),this.setStyle(this.style)}},{key:"createMesh",value:function(e,t){}},{key:"setStyle",value:function(e){var t=e.img,r=e.color,n=e.opacity,o=e.size,a=e.lineColor,i=e.lineOpacity;void 0!==r&&this.material.color.set(r),void 0!==n&&(this.material.opacity=n),void 0!==o&&(this.material.size=o),void 0!==t&&(this.material.map=this.view.textureLoader.load(t)),void 0!==a&&this.lineMaterial.color.set(a),void 0!==i&&(this.lineMaterial.opacity=i)}}]),r}(c.default)},443:function(e,t,r){"use strict";r.r(t),r.d(t,"default",(function(){return d}));var n=r(19),o=r(20),a=r(23),i=r(21),s=r(22),l=r(44),c=r(45),u=r(162),h=r(139),f=r(188),d=function(e){Object(i.a)(r,e);var t=Object(s.a)(r);function r(e){var o;return Object(n.a)(this,r),(o=t.call(this)).style={effect:!1,opacity:.5,color:"#DD3217",outlineColor:"#ffa108",outlineOpacity:1,height:2e3},Object.assign(Object(a.a)(o),e),o.init(),o}return Object(o.a)(r,[{key:"init",value:function(){this.material=new l.MeshBasicMaterial({color:this.style.color,transparent:!0,opacity:this.style.opacity}),this.lineMaterial=new l.MeshBasicMaterial({color:this.style.outlineColor,opacity:this.style.outlineOpacity})}},{key:"geoJSON",value:function(e){var t=this;f.a.toGeometry(e,(function(e){"MultiPolygon"!==e.type&&"Polygon"!==e.type||t.createMesh("Polygon"===e.type?[e.coordinates]:e.coordinates,{height:t.style.height})}))}},{key:"setData",value:function(e){this.clear(),this.geoJSON(e),this.setStyle(this.style)}},{key:"createMesh",value:function(e,t){var r=new l.Group;this.node.add(r);for(var n=t.height,o=0;o<e.length;o++){for(var a=[],i=[],s=0;s<e[o].length;s++)if(0===s)for(var u=0;u<e[o][s].length;u++){var f=h.a.lonLatToWorld(e[o][s][u]);a.push({x:f[0],y:f[1],z:f[2]})}else{for(var d=[],m=0;m<e[o][s].length;m++){var v=h.a.lonLatToWorld(e[o][s][m]);d.push({x:v[0],y:v[1],z:v[2]})}var p=new c.PolygonHierarchy(d);i.push(p)}for(var g=new c.PolygonHierarchy(a,i),y=new c.PolygonGeometry({polygonHierarchy:g,extrudedHeight:n}),C=(y=c.PolygonGeometry.createGeometry(y)).indices,x=y.attributes.position.values,b=new Float32Array(x.length),w=y.attributes.st.values,S=y.attributes.normal.values,P=0;P<x.length;P++){var M=[x[3*P],x[3*P+1],x[3*P+2]];b[3*P]=M[0],b[3*P+1]=M[1],b[3*P+2]=M[2]}(y=new l.BufferGeometry).setIndex(new l.BufferAttribute(C,1)),y.setAttribute("position",new l.BufferAttribute(b,3)),y.setAttribute("uv",new l.BufferAttribute(w,2)),y.setAttribute("normal",new l.BufferAttribute(S,3));var A=new l.Mesh(y,this.material);r.add(A);var _=new c.PolygonOutlineGeometry({polygonHierarchy:new c.PolygonHierarchy(g.positions),extrudedHeight:n}),O=(_=new c.PolygonOutlineGeometry.createGeometry(_)).attributes.position.values;(_=new l.BufferGeometry).setAttribute("position",new l.Float32BufferAttribute(O,3));var I=new l.Line(_,this.lineMaterial);r.add(I)}}},{key:"setStyle",value:function(e){var t=e.color,r=e.opacity,n=e.height,o=e.outlineColor,a=e.outlineOpacity,i=e.effect;if(void 0!==t&&this.material.color.set(t),void 0!==r&&(this.material.opacity=r),void 0!==o&&this.lineMaterial.color.set(o),void 0!==a&&(this.lineMaterial.opacity=a),void 0!==n){void 0!==this.preHeight&&null!==this.preHeight||(this.preHeight=n);var s=n/this.preHeight;this.node.children.forEach((function(e){e.scale.y=s||1}))}this.setEffect(i)}},{key:"setEffect",value:function(e){for(var t=0;t<this.node.children.length;t++)for(var r=0;r<this.node.children[t].children.length;r++)this.updateEffect(this.node.children[t].children[r],{name:"urealBloom",value:.3},e)}}]),r}(u.default)},444:function(e,t,r){"use strict";r.r(t),r.d(t,"default",(function(){return f}));var n=r(19),o=r(20),a=r(23),i=r(21),s=r(22),l=r(44),c=r(162),u=r(139),h=r(188),f=(r(0),function(e){Object(i.a)(r,e);var t=Object(s.a)(r);function r(e){var o;return Object(n.a)(this,r),(o=t.call(this)).style={height:0,color:"#FF9400",opacity:1,speed:.01},Object.assign(Object(a.a)(o),e),o.init(),o}return Object(o.a)(r,[{key:"init",value:function(){this.material=new l.ShaderMaterial({uniforms:{time:{type:"f",value:0},color:{type:"c",value:new l.Color("#ff326e")},opacity:{type:"f",value:1}},vertexShader:"\n                #include <common>\n                #include <logdepthbuf_pars_vertex>\n                //precision lowp float;\n                //precision lowp int;\n                varying vec2 vUv;\n                void main() {\n                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                    #include <logdepthbuf_vertex>\n                }\n            ",fragmentShader:"\n                #include <common>\n                #include <logdepthbuf_pars_fragment>\n                //#if __VERSION__ == 100\n                    //#extension GL_OES_standard_derivatives : enable\n                //#endif\n                uniform vec3 color;\n                uniform float opacity;\n                uniform float time;\n                varying vec2 vUv;\n                #define pi 3.1415926535\n                #define PI2RAD 0.01745329252\n                #define TWO_PI (2. * PI)\n                float rands(float p) {\n                    return fract(sin(p) * 10000.0);\n                }\n                float noise(vec2 p) {\n                    float t = time / 20000.0;\n                    if(t > 1.0) t -= floor(t);\n                    return rands(p.x * 14. + p.y * sin(t) * 0.5);\n                }\n                vec2 sw(vec2 p) {\n                    return vec2(floor(p.x), floor(p.y));\n                }\n                vec2 se(vec2 p) {\n                    return vec2(ceil(p.x), floor(p.y));\n                }\n                vec2 nw(vec2 p) {\n                    return vec2(floor(p.x), ceil(p.y));\n                }\n                vec2 ne(vec2 p) {\n                    return vec2(ceil(p.x), ceil(p.y));\n                }\n                float smoothNoise(vec2 p) {\n                    vec2 inter = smoothstep(0.0, 1.0, fract(p));\n                    float s = mix(noise(sw(p)), noise(se(p)), inter.x);\n                    float n = mix(noise(nw(p)), noise(ne(p)), inter.x);\n                    return mix(s, n, inter.y);\n                }\n                float fbm(vec2 p) {\n                    float z = 2.0;\n                    float rz = 0.0;\n                    vec2 bp = p;\n                    for(float i = 1.0; i < 6.0; i++) {\n                        rz += abs((smoothNoise(p) - 0.5)* 2.0) / z;\n                        z *= 2.0;\n                        p *= 2.0;\n                    }\n                    return rz;\n                }\n                void main() {\n                    vec2 uv = vUv;\n                    vec2 uv2 = vUv;\n                    if (uv.y < 0.5) {\n                        discard;\n                    }\n                    uv *= 4.;\n                    float rz = fbm(uv);\n                    uv /= exp(mod(time * 2.0, pi));\n                    rz *= pow(15., 0.9);\n                    gl_FragColor = mix(vec4(color, opacity) / rz, vec4(color, 0.1), 0.2);\n                    if (uv2.x < 0.05) {\n                        gl_FragColor = mix(vec4(color, 0.1), gl_FragColor, uv2.x / 0.05);\n                    }\n                    if (uv2.x > 0.95) {\n                        gl_FragColor = mix(gl_FragColor, vec4(color, 0.1), (uv2.x - 0.95) / 0.05);\n                    }\n                    #include <logdepthbuf_fragment>\n                }\n            ",blending:l.AdditiveBlending,depthWrite:!1,depthTest:!0,side:l.DoubleSide,transparent:!0,opacity:1})}},{key:"geoJSON",value:function(e){var t=this;h.a.toGeometry(e,(function(e){"MultiPoint"!==e.type&&"Point"!==e.type||t.createMesh("Point"===e.type?[e.coordinates]:e.coordinates,{height:void 0!==e.properties.height&&null!==e.properties.height?e.properties.height:t.height})}))}},{key:"setData",value:function(e){this.clear();for(var t=0;t<e.length;t++){var r=u.a.lonLatToWorld([e[t].lng,e[t].lat]),n=new l.SphereBufferGeometry(200,200,200,200,2*Math.PI),o=new l.Mesh(n,this.material);o.position.x=r[0],o.position.y=r[1],o.position.z=r[2],u.a.setDirection(o,r,[0,1,0]),this.node.add(o)}this.setStyle(this.style)}},{key:"createMesh",value:function(e,t){}},{key:"setStyle",value:function(e){e.height;var t=e.color,r=e.opacity,n=e.speed;void 0!==t&&this.material.uniforms.color.value.setStyle(t),void 0!==r&&(this.material.uniforms.opacity.value=r),void 0!==n&&(this.style.speed=n)}},{key:"update",value:function(){this.material&&(this.material.uniforms.time.value+=this.style.speed)}}]),r}(c.default))},751:function(e,t){e.exports="//varying vec4 Position;\r\n//precision highp float;\r\n//varying vec3 ModelPostion;\r\n#include <common>\r\n#include <packing>\r\n#include <fog_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <shadowmap_pars_fragment>\r\n#include <shadowmask_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\nvarying float v_distance;\r\nvarying vec3 PositionWS;\r\nvarying vec2 texCoords;\r\n\r\nuniform bool grayFilterEnable;\r\n//uniform float grayMinMax[2];\r\n//uniform float grayFilterPerBar[10];\r\n//uniform vec3 grayFilterColorBar[10];\r\nuniform float shadowOpacity;\r\n\r\nuniform sampler2D TexSampler0;\r\n\r\nuniform\tvec4 textureRectangle0;\r\n\r\nuniform\tvec4 textureTransAndScale0;\r\n\r\nuniform float brightness0;\r\n\r\nuniform float alphaIndex0;\r\n\r\nuniform float isAddEffect0;\r\nuniform vec4 earthColor0;\r\nuniform vec4 earthAddColor0;\r\n\r\nuniform float south1;\r\nuniform float north1;\r\nuniform float southMercatorY1;\r\nuniform float oneOverMercatorHeight1;\r\nuniform float isReProjection;\r\n\r\n\r\n\r\nuniform\tfloat Km;\r\nuniform\tfloat Kr;\r\nuniform\tfloat ESun;\r\n\r\nuniform int nSamples;\r\nuniform float fSamples;\r\n\r\n//uniform float g,\r\n\r\n//uniform\tvec3 v3CameraPosInput;\r\nuniform\tvec3 v3LightPosInput;\r\n\r\nuniform\tfloat fInnerRadius;\r\nuniform\tfloat fOuterRadius;\r\n\r\nuniform float fScaleDepth;\r\nuniform\tvec4 inputColor;\r\nuniform vec4 alphaValue;\r\n\r\nuniform float night;\r\n\r\nuniform float contrast;\r\nuniform float hue;\r\nuniform float saturation;\r\nuniform float textureGamma;\r\n\r\nuniform vec4 u_initialColor;\r\nuniform float nightfadeIn;\r\nuniform float nightfadeOut;\r\nuniform float fadeInDist;\r\nuniform float fadeOutDist;\r\n\r\nuniform float czm_fogDensity;\r\nuniform sampler2D colorMapping;\r\n\r\n//#define saturate(a) clamp( a, 0.0, 1.0 )\r\n//#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n//#define LOG2 1.442695\r\n\t\t\t\r\nstruct czm_ellipsoid {\r\n    vec3 center;\r\n    vec3 radii;\r\n    vec3 inverseRadii;\r\n    vec3 inverseRadiiSquared;\r\n};\r\nstruct AtmosphereColor {\r\n    vec3 mie;\r\n    vec3 rayleigh;\r\n};\r\n//uniform vec4 earthColor;\r\n//uniform vec4 earthAddColor;\r\n//uniform float isAddEffect;\r\nfloat scale(float fCos, float fScaleDepth) {\r\n    float x = 1.0 - fCos;\r\n    return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\r\n}\r\nvec4 depthColor(vec4 color) {\r\n        color.r = color.r * color.r * color.r;\r\n        color.g = color.g * color.g * color.g;\r\n        color.b = color.b * color.b;\r\n        return color;\r\n}\r\n\r\n// Returns the near intersection point of a line and a sphere\r\nfloat getNearIntersection(vec3 v3Pos, vec3 v3Ray, float fDistance2, float fRadius2) {\r\n    float B = 2.0 * dot(v3Pos, v3Ray);\r\n    float C = fDistance2 - fRadius2;\r\n    float fDet = max(0.0, B*B - 4.0 * C);\r\n    return 0.5 * (-B - sqrt(fDet));\r\n}\r\n\t\t\t\r\n//we must convert rgb to a right factor.\r\nvec3 czm_contrast(vec3 rgb, float contrast){\r\n    vec3 color = mix(vec3(0.5), rgb, contrast);\r\n    color = clamp(color , 0.0, 1.0);\r\n    return color;\r\n}\r\n\t\t\t\r\nvec3 czm_hue(vec3 rgb, float adjustment) {\r\n    const mat3 toYIQ = mat3(0.299, 0.587, 0.114,\r\n                        0.595716, -0.274453, -0.321263,\r\n                        0.211456, -0.522591, 0.311135);\r\n    const mat3 toRGB = mat3(1.0, 0.9563, 0.6210,\r\n                        1.0, -0.2721, -0.6474,\r\n                        1.0, -1.107, 1.7046);\r\n    vec3 yiq = toYIQ * rgb;\r\n    float hue = atan(yiq.z, yiq.y) + adjustment;\r\n    float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\r\n    vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\r\n    vec3 final = toRGB * color;\r\n    final = clamp(final , 0.0, 1.0);\r\n    return final;\r\n}\r\n\r\nvec3 czm_saturation(vec3 rgb, float adjustment) {\r\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\r\n    vec3 intensity = vec3(dot(rgb, W));\r\n    vec3 color = mix(intensity, rgb, adjustment);\r\n    color = clamp(color , 0.0, 1.0);\r\n    return color;\r\n\r\n}\r\n\t\t\t\r\nvec4 sampleAndBlend(\r\n    float addEffect,\r\n    vec4 eColor,\r\n    vec4 addColor,\r\n    vec4 previousColor,\r\n    sampler2D sampler_texture,\r\n    vec2 tileTextureCoordinates,\r\n    vec4 textureCoordinateRectangle,\r\n    vec4 textureCoordinateTranslationAndScale,\r\n    float textureAlphaIndex,\r\n    float brightness,\r\n    float south,\r\n    float north,\r\n    float southMercatorY,\r\n    float oneOverMercatorHeight,\r\n    float isReProjection,\r\n    vec4 alphaValue,\r\n    float contrast,\r\n    float hue,\r\n    float saturation,\r\n    float gamma\r\n) {\r\n\r\n    float textureAlpha = 1.0;\r\n    vec2 alphaMultiplier = step(textureCoordinateRectangle.xy, tileTextureCoordinates);\r\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\r\n\r\n    alphaMultiplier = step(vec2(0.0,0.0), textureCoordinateRectangle.zw - tileTextureCoordinates);\r\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\r\n\r\n    vec2 translation = textureCoordinateTranslationAndScale.xy;\r\n    vec2 scale = textureCoordinateTranslationAndScale.zw;\r\n    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\r\n\r\n    //\u518d\u6295\u5f71\r\n    float latitude = mix(south, north , textureCoordinates.y);\r\n    float sinLatitude = sin(latitude);\r\n    float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\r\n    float mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;\r\n    textureCoordinates.y =  mercatorFraction;\r\n\r\n    if( isReProjection == 0.0){\r\n        textureCoordinates.y = (tileTextureCoordinates * scale + translation).y;\r\n    }\r\n    //textureCoordinates = clamp(textureCoordinates, 1.0/256.0, 255.0/256.0);\r\n    vec4 value = texture2D(sampler_texture, textureCoordinates);\r\n    if(addEffect == 1.0) {\r\n        value = depthColor(value);\r\n    }\r\n\r\n    value.rgb *=eColor.rgb;\r\n//      if(eColor.a==1.0){\r\n//        value *=eColor;\r\n//      }\r\n//      else{\r\n////        value.rgb = (value.rgb + eColor.rgb * eColor.a)/(1.0 + eColor.a);\r\n//        value.rgb = value.rgb * (1.0-eColor.a) + eColor.rgb * eColor.a;\r\n//      }\r\n\r\n    value.rgb = (value.rgb + addColor.rgb * addColor.a) / (1.0 + addColor.a);\r\n    vec3 color = value.rgb;\r\n    float alpha = value.a;\r\n    //brightness\r\n    color = mix(vec3(0.0,0.0,0.0), color, brightness);\r\n    //contrast\r\n    color = czm_contrast(color, contrast);\r\n    //hue\r\n    color = czm_hue(color, hue);\r\n    // saturation\r\n    color = czm_saturation(color, saturation);\r\n    // gamma\r\n    color = pow(color, vec3(gamma));\r\n    float sourceAlpha = alpha * textureAlpha;\r\n    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\r\n    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\r\n    return vec4(outColor, outAlpha);\r\n}\r\n\t\t\t\r\n//czm_ellipsoid czm_getWgs84EllipsoidEC()\r\n//{\r\n//    vec3 radii = vec3(6378137.0, 6378137.0, 6356752.314245);\r\n//    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\r\n//    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\r\n//    czm_ellipsoid temp = czm_ellipsoid(viewMatrix[3].xyz, radii, inverseRadii, inverseRadiiSquared);\r\n//    return temp;\r\n//}\r\nfloat czm_fade(float cameraDist, float fadeInDist,float fadeOutDist) {\r\n    float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\r\n    return fade;\r\n}\r\nAtmosphereColor computeGroundAtmosphereFromSpace(vec3 v3Pos, bool useSunLighting) {\r\n//        float PI = 3.14159265;\r\n        //float g2 =  g * g;\r\n\r\n    vec3 v3InvWavelength = vec3(1.0 / pow(0.650, 4.0), 1.0 / pow(0.570, 4.0), 1.0 / pow(0.475, 4.0));\r\n\r\n    vec3 v3CameraPos =  vec3(0.0, 0.0, 0.0);\r\n    v3CameraPos = cameraPosition;\r\n\r\n    vec3 v3LightPos = v3LightPosInput / length(v3LightPosInput);\r\n\r\n    float fCameraHeight = length(v3CameraPos);\r\n\r\n    float fCameraHeight2 = fCameraHeight * fCameraHeight;\r\n\r\n    float inOutFactor = 1.05;\r\n    float fInnerRadius2 = fInnerRadius * fInnerRadius;\r\n    float fOuterRadius2 = fOuterRadius * fOuterRadius;\r\n\r\n    float fKrESun = Kr * ESun;\r\n    float fKmESun = Km * ESun;\r\n    float fKr4PI = Kr * 4.0 * PI;\r\n    float fKm4PI = Km * 4.0 * PI;\r\n\r\n    float fInvScaleDepth = 1.0 / fScaleDepth;\r\n    float fScale = 1.0 / (fOuterRadius - fInnerRadius);\r\n    float fScaleOverScaleDepth = fScale / fScaleDepth;\r\n\r\n    ////////////////////////////////////////////////\r\n    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\r\n    // vec3 v3Pos = PositionWS;\r\n    vec3 v3Ray = v3Pos - v3CameraPos;\r\n    v3Pos = normalize(v3Pos);\r\n    float fFar = length(v3Ray);\r\n    v3Ray /= fFar;\r\n    // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\r\n    float fNear = getNearIntersection(v3CameraPos, v3Ray, fCameraHeight2, fOuterRadius2);\r\n    // Calculate the ray's starting position, then calculate its scattering offset\r\n    vec3 v3Start = v3CameraPos + v3Ray * fNear;\r\n    fFar -= fNear;\r\n    float fDepth = exp((fInnerRadius - fOuterRadius) * fInvScaleDepth);\r\n\r\n    //if you donnot want night make it 1.0\r\n    float fLightAngle = useSunLighting ? dot(v3LightPos, v3Pos)/length(v3Pos) : 1.0;\r\n    float fCameraAngle = dot(-v3Ray, v3Pos)/length(v3Pos);\r\n    //float fLightAngle = dot(v3LightPos, v3Pos);\r\n    float fCameraScale = scale(fCameraAngle, fScaleDepth);\r\n    float fLightScale = scale(fLightAngle, fScaleDepth);\r\n    float fCameraOffset = fDepth*fCameraScale;\r\n    float fTemp = (fLightScale + fCameraScale);\r\n    // Initialize the scattering loop variables\r\n    //gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);\r\n    float fSampleLength = fFar / fSamples;\r\n    float fScaledLength = fSampleLength * fScale;\r\n    vec3 v3SampleRay = v3Ray * fSampleLength;\r\n    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\r\n    // Now loop through the sample rays\r\n    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\r\n    vec3 v3Attenuate = vec3(0.0,0.0,0.0);\r\n    for(int i = 0; i < 2; i++) {\r\n        float fHeight = length(v3SamplePoint);\r\n        float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\r\n        float fScatter = fDepth*fTemp - fCameraOffset;\r\n        v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\r\n        v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\r\n        v3SamplePoint += v3SampleRay;\r\n    }\r\n    AtmosphereColor color;\r\n    color.mie = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\r\n    color.rayleigh = v3Attenuate;\r\n    return color;\r\n\r\n}\r\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor) {\r\n    float scalar = distanceToCamera * czm_fogDensity;\r\n    float fog = 1.0 - exp(-(scalar * scalar));\r\n    return mix(color, fogColor, fog);\r\n}\r\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant) {\r\n    float scalar = distanceToCamera * czm_fogDensity;\r\n    float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\r\n    return mix(color, fogColor, fog);\r\n}\r\n\t\t\t\t\r\nvec4 czm_FilterColor(vec4 finalColor) {\r\n    vec4 finalColor1 = vec4(0);\r\n    if(grayFilterEnable) {\r\n        float gray = clamp( dot(finalColor.rgb, vec3(0.333, 0.333, 0.333)), 0.0, 1.0);\r\n        finalColor1.rgb = texture2D(colorMapping, vec2(gray, 0.5)).rgb;\r\n        finalColor1.a = finalColor.a;\r\n    } else {\r\n        finalColor1 = finalColor;\r\n    }\r\n    return finalColor1;\r\n}\r\nvoid main() {\r\n    #include <logdepthbuf_fragment>\r\n    //vec2 texCoords = vec2(gl_TexCoord[0]);\r\n    vec2 webglUv = texCoords;\r\n    //webglUv.y =1.0 - webglUv.y;\r\n    webglUv = clamp(webglUv , 0.0, 1.0);\r\n    vec4 lastColor = sampleAndBlend(isAddEffect0,earthColor0,earthAddColor0,u_initialColor,TexSampler0,webglUv,textureRectangle0,textureTransAndScale0,alphaIndex0,brightness0,south1,north1,southMercatorY1,oneOverMercatorHeight1,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\r\n    //to caculate fog\r\n    //float cameraDist = length(viewMatrix[3]);\r\n    float cameraDist = length(cameraPosition);\r\n    float fade = czm_fade(cameraDist, fadeInDist, fadeOutDist);\r\n    //added lambertDiffuse TODO is it effective? \u8fd9\u4e2a\u5f88\u4e00\u822c\uff0c\u5148\u5ffd\u7565\u5427\uff0c\u6bd5\u7adf\u54b1\u4eec\u6027\u80fd\u4e0d\u592a\u597d\u554a\r\n    //float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_sunDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\r\n    //diffuseIntensity = mix(1.0, diffuseIntensity, fade);\r\n    //vec4 finalColor = vec4(color.rgb * diffuseIntensity, color.a);\r\n    vec4 finalColor = lastColor;\r\n    //added fogColor and hdr\r\n    AtmosphereColor atmosFogColor = computeGroundAtmosphereFromSpace(PositionWS, false);\r\n    vec3 c0 = atmosFogColor.mie;\r\n    vec3 c1 = atmosFogColor.rayleigh;\r\n    vec3 fogColor1 = c0 + finalColor.rgb * c1;\r\n    //we should use hdr\r\n    const float fExposure = 2.0;\r\n    fogColor1 = vec3(1.0) - exp(-fExposure * fogColor1);\r\n    //fog added, use my fog istead of cesium\r\n    // const float modifier = 0.15;\r\n    finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor1), finalColor.a);\r\n    //ground\r\n    //SUN \u8fd9\u4e2asun\u7684\u8ba1\u7b97\u5904\u7406\u4e86\u4e0b\uff0c\u6211\u4eec\u4e0d\u80fd\u548ccesium\u7528\u4e00\u6837\u7684\u53c2\u6570\uff0c\u8fd9\u6837\u53ef\u80fd\u65e0\u6cd5\u6a21\u62df\u771f\u5b9e\u592a\u9633\u7684\u4f4d\u7f6e\r\n    vec3 groundAtmosphereColor = vec3(0.0);\r\n    if(night == 1.0) {\r\n        AtmosphereColor atmosColor = computeGroundAtmosphereFromSpace(PositionWS, true);\r\n        groundAtmosphereColor = atmosColor.mie + finalColor.rgb * atmosColor.rayleigh;\r\n        groundAtmosphereColor = vec3(1.0) - exp(-fExposure * groundAtmosphereColor);\r\n        //TODO \u8fd9\u4e2a\u53ef\u80fd\u8981\u5f31\u4e00\u70b9\u624d\u884c\r\n        float sunlitAtmosphereIntensity = clamp((cameraDist - nightfadeOut) / (nightfadeIn - nightfadeOut), 0.0, 1.0);//caculate sun\r\n        // used hdr to make HDR look better\r\n        sunlitAtmosphereIntensity = max(sunlitAtmosphereIntensity * sunlitAtmosphereIntensity, 0.03);\r\n        //mix sun\r\n        groundAtmosphereColor = mix(groundAtmosphereColor, fogColor1, sunlitAtmosphereIntensity);\r\n    } else {\r\n        groundAtmosphereColor = fogColor1;\r\n    }\r\n    //use saturation to look better\r\n    groundAtmosphereColor = czm_saturation(groundAtmosphereColor, 1.6);\r\n    //mix\r\n    finalColor = vec4(mix(finalColor.rgb, groundAtmosphereColor, fade), finalColor.a);\r\n    finalColor.rgb *= vec3(earthColor0.a);\r\n    //finally you get the color\r\n    finalColor = czm_FilterColor(finalColor);\r\n    gl_FragColor = finalColor;\r\n    //now we get the shadow\r\n    //gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), (1.0-getShadowMask()));\r\n    vec4 shadow = vec4(vec3(0.0), shadowOpacity * (1.0 - getShadowMask()));\r\n    gl_FragColor.rgb = mix(gl_FragColor.rgb, shadow.rgb, shadow.a);\r\n    #include <fog_fragment>\r\n}"},752:function(e,t){e.exports="//varying vec4 Position;\r\n//precision highp float;\r\n#include <common>\r\n#include <packing>\r\n#include <fog_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <shadowmap_pars_fragment>\r\n#include <shadowmask_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\nvarying vec3 PositionWS;\r\nvarying vec2 texCoords;\r\n//varying vec3 ModelPostion;\r\nvarying float v_distance;\r\n\r\nuniform bool grayFilterEnable;\r\nuniform float shadowOpacity;\r\n//uniform float grayMinMax[2];\r\n//uniform float grayFilterPerBar[10];\r\n//uniform vec3 grayFilterColorBar[10];\r\n\r\nuniform sampler2D TexSampler0;\r\nuniform sampler2D TexSampler1;\r\n\r\nuniform\tvec4 textureRectangle0;\r\nuniform\tvec4 textureRectangle1;\r\n\r\nuniform\tvec4 textureTransAndScale0;\r\nuniform\tvec4 textureTransAndScale1;\r\n\r\nuniform float brightness0;\r\nuniform float brightness1;\r\n\r\nuniform float alphaIndex0;\r\nuniform float alphaIndex1;\r\n\r\nuniform float isAddEffect0;\r\nuniform float isAddEffect1;\r\n\r\n\r\nuniform vec4 earthColor0;\r\nuniform vec4 earthColor1;\r\n\r\nuniform vec4 earthAddColor0;\r\nuniform vec4 earthAddColor1;\r\n\r\n\r\nuniform float south1;\r\nuniform float north1;\r\nuniform float southMercatorY1;\r\nuniform float oneOverMercatorHeight1;\r\nuniform float isReProjection;\r\n\r\nuniform float south2;\r\nuniform float north2;\r\nuniform float southMercatorY2;\r\nuniform float oneOverMercatorHeight2;\r\n\r\nuniform\tfloat Km;\r\nuniform\tfloat Kr;\r\nuniform\tfloat ESun;\r\n\r\nuniform int nSamples;\r\nuniform float fSamples;\r\n\r\n//uniform float g,\r\n\r\n//uniform\tvec3 v3CameraPosInput;\r\nuniform\tvec3 v3LightPosInput;\r\n\r\nuniform\tfloat fInnerRadius;\r\nuniform\tfloat fOuterRadius;\r\n\r\nuniform float fScaleDepth;\r\nuniform\tvec4 inputColor;\r\nuniform vec4 alphaValue;\r\nuniform float night;\r\n\r\nuniform float contrast;\r\nuniform float hue;\r\nuniform float saturation;\r\nuniform float textureGamma;\r\n\r\nuniform vec4 u_initialColor;\r\nuniform float nightfadeIn;\r\nuniform float nightfadeOut;\r\nuniform float fadeInDist;\r\nuniform float fadeOutDist;\r\n\r\nuniform float czm_fogDensity;\r\nuniform sampler2D colorMapping;\r\n\r\n//#define saturate(a) clamp(a, 0.0, 1.0)\r\n//#define whiteCompliment(a) (1.0 - saturate(a))\r\n//#define LOG2 1.442695\r\nstruct czm_ellipsoid {\r\n    vec3 center;\r\n    vec3 radii;\r\n    vec3 inverseRadii;\r\n    vec3 inverseRadiiSquared;\r\n};\r\nstruct AtmosphereColor {\r\n    vec3 mie;\r\n    vec3 rayleigh;\r\n};\r\n\r\n//uniform vec4 earthColor;\r\n//uniform vec4 earthAddColor;\r\n//uniform float isAddEffect;\r\n\r\nfloat scale(float fCos, float fScaleDepth) {\r\n    float x = 1.0 - fCos;\r\n    return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\r\n}\r\n\r\nvec4 depthColor(vec4 color) {\r\n    color.r = color.r * color.r * color.r;\r\n    color.g = color.g * color.g * color.g;\r\n    color.b = color.b * color.b;\r\n    return color;\r\n}\r\n\r\n// Returns the near intersection point of a line and a sphere\r\nfloat getNearIntersection(vec3 v3Pos, vec3 v3Ray, float fDistance2, float fRadius2) {\r\n    float B = 2.0 * dot(v3Pos, v3Ray);\r\n    float C = fDistance2 - fRadius2;\r\n    float fDet = max(0.0, B*B - 4.0 * C);\r\n    return 0.5 * (-B - sqrt(fDet));\r\n}\r\n\r\nvec3 czm_contrast(vec3 rgb, float contrast) {\r\n    vec3 color = mix(vec3(0.5), rgb, contrast);\r\n    color = clamp(color , 0.0, 1.0);\r\n    return color;\r\n}\r\n\r\nvec3 czm_hue(vec3 rgb, float adjustment) {\r\n    const mat3 toYIQ = mat3(0.299, 0.587, 0.114,\r\n                            0.595716, -0.274453, -0.321263,\r\n                            0.211456, -0.522591, 0.311135);\r\n    const mat3 toRGB = mat3(1.0, 0.9563, 0.6210,\r\n                            1.0, -0.2721, -0.6474,\r\n                            1.0, -1.107, 1.7046);\r\n    vec3 yiq = toYIQ * rgb;\r\n    float hue = atan(yiq.z, yiq.y) + adjustment;\r\n    float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\r\n    vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\r\n    vec3 final = toRGB * color;\r\n    final = clamp(final, 0.0, 1.0);\r\n    return final;\r\n}\r\n\r\nvec3 czm_saturation(vec3 rgb, float adjustment) {\r\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\r\n    vec3 intensity = vec3(dot(rgb, W));\r\n    vec3 color = mix(intensity, rgb, adjustment);\r\n    color = clamp(color , 0.0, 1.0);\r\n    return color;\r\n\r\n}\r\n\r\nvec4 sampleAndBlend(\r\n    float addEffect,\r\n    vec4 eColor,\r\n    vec4 addColor,\r\n    vec4 previousColor,\r\n    sampler2D sampler_texture,\r\n    vec2 tileTextureCoordinates,\r\n    vec4 textureCoordinateRectangle,\r\n    vec4 textureCoordinateTranslationAndScale,\r\n    float textureAlphaIndex,\r\n    float brightness,\r\n    float south,\r\n    float north,\r\n    float southMercatorY,\r\n    float oneOverMercatorHeight,\r\n    float isReProjection,\r\n    vec4 alphaValue,\r\n    float contrast,\r\n    float hue,\r\n    float saturation,\r\n    float gamma\r\n) {\r\n    float textureAlpha = 1.0;\r\n    vec2 alphaMultiplier = step(textureCoordinateRectangle.xy, tileTextureCoordinates);\r\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\r\n\r\n    alphaMultiplier = step(vec2(0.0,0.0), textureCoordinateRectangle.zw - tileTextureCoordinates);\r\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\r\n\r\n    vec2 translation = textureCoordinateTranslationAndScale.xy;\r\n    vec2 scale = textureCoordinateTranslationAndScale.zw;\r\n    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\r\n\r\n    //\u518d\u6295\u5f71\r\n    float latitude = mix(south, north , textureCoordinates.y);\r\n    float sinLatitude = sin(latitude);\r\n    float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\r\n    float mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;\r\n    textureCoordinates.y =  mercatorFraction;\r\n\r\n    if( isReProjection == 0.0){\r\n        textureCoordinates.y =  (tileTextureCoordinates * scale + translation).y;\r\n    }\r\n    //textureCoordinates = clamp(textureCoordinates, 1.0/256.0, 255.0/256.0);\r\n    vec4 value = texture2D(sampler_texture, textureCoordinates);\r\n    if(addEffect == 1.0){\r\n        value = depthColor(value);\r\n    }\r\n    value.rgb *= eColor.rgb;\r\n//           if(eColor.a==1.0){\r\n//                 value *=eColor;\r\n//               }\r\n//               else{\r\n//                 //value.rgb = (value.rgb + eColor.rgb * eColor.a)/(1.0 + eColor.a);\r\n//                  value.rgb = value.rgb * (1.0-eColor.a) + eColor.rgb * eColor.a;\r\n//               }\r\n    value.rgb = (value.rgb + addColor.rgb * addColor.a)/(1.0 + addColor.a);\r\n    vec3 color = value.rgb;\r\n    float alpha = value.a;\r\n//\r\n    color = mix(vec3(0.0,0.0,0.0), color, brightness);\r\n    //contrast\r\n    color = czm_contrast(color, contrast);\r\n    //hue\r\n    color = czm_hue(color, hue);\r\n    // saturation\r\n    color = czm_saturation(color, saturation);\r\n    // gamma\r\n    color = pow(color, vec3(gamma));\r\n\r\n    float sourceAlpha = alpha * textureAlpha;\r\n    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\r\n    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\r\n    return vec4(outColor, outAlpha);\r\n}\r\n\r\n//czm_ellipsoid czm_getWgs84EllipsoidEC()\r\n//{\r\n//    vec3 radii = vec3(6378137.0, 6378137.0, 6356752.314245);\r\n//    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\r\n//    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\r\n//    czm_ellipsoid temp = czm_ellipsoid(viewMatrix[3].xyz, radii, inverseRadii, inverseRadiiSquared);\r\n//    return temp;\r\n//}\r\nfloat czm_fade(float cameraDist, float fadeInDist,float fadeOutDist) {\r\n    float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\r\n    return fade;\r\n}\r\nAtmosphereColor computeGroundAtmosphereFromSpace(vec3 v3Pos, bool useSunLighting){\r\n    //float PI = 3.14159265;\r\n    //float g2 =  g * g;\r\n\r\n    vec3 v3InvWavelength = vec3(1.0 / pow(0.650, 4.0), 1.0 / pow(0.570, 4.0), 1.0 / pow(0.475, 4.0));\r\n\r\n    vec3 v3CameraPos = vec3(0.0, 0.0, 0.0);\r\n    v3CameraPos = cameraPosition;\r\n\r\n    vec3 v3LightPos = v3LightPosInput / length(v3LightPosInput);\r\n\r\n    float fCameraHeight = length(v3CameraPos);\r\n\r\n    float fCameraHeight2 = fCameraHeight * fCameraHeight;\r\n\r\n    float inOutFactor = 1.05;\r\n    float fInnerRadius2 = fInnerRadius * fInnerRadius;\r\n    float fOuterRadius2 = fOuterRadius * fOuterRadius;\r\n\r\n    float fKrESun = Kr * ESun;\r\n    float fKmESun = Km * ESun;\r\n    float fKr4PI = Kr * 4.0 * PI;\r\n    float fKm4PI = Km * 4.0 * PI;\r\n\r\n    float fInvScaleDepth = 1.0 / fScaleDepth;\r\n    float fScale = 1.0 / (fOuterRadius - fInnerRadius);\r\n    float fScaleOverScaleDepth = fScale / fScaleDepth;\r\n\r\n    ////////////////////////////////////////////////\r\n    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\r\n    //vec3 v3Pos = PositionWS;\r\n    vec3 v3Ray = v3Pos - v3CameraPos;\r\n    v3Pos = normalize(v3Pos);\r\n    float fFar = length(v3Ray);\r\n    v3Ray /= fFar;\r\n    // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\r\n    float fNear = getNearIntersection(v3CameraPos, v3Ray, fCameraHeight2, fOuterRadius2);\r\n    // Calculate the ray's starting position, then calculate its scattering offset\r\n    vec3 v3Start = v3CameraPos + v3Ray * fNear;\r\n    fFar -= fNear;\r\n    float fDepth = exp((fInnerRadius - fOuterRadius) * fInvScaleDepth);\r\n\r\n    //if you donnot want night make it 1.0\r\n    float fLightAngle = useSunLighting ? dot(v3LightPos, v3Pos)/length(v3Pos) : 1.0;\r\n    float fCameraAngle = dot(-v3Ray, v3Pos)/length(v3Pos);\r\n    //float fLightAngle = dot(v3LightPos, v3Pos);\r\n    float fCameraScale = scale(fCameraAngle, fScaleDepth);\r\n    float fLightScale = scale(fLightAngle, fScaleDepth);\r\n    float fCameraOffset = fDepth*fCameraScale;\r\n    float fTemp = (fLightScale + fCameraScale);\r\n    // Initialize the scattering loop variables\r\n    //gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);\r\n    float fSampleLength = fFar / fSamples;\r\n    float fScaledLength = fSampleLength * fScale;\r\n    vec3 v3SampleRay = v3Ray * fSampleLength;\r\n    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\r\n    // Now loop through the sample rays\r\n    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\r\n    vec3 v3Attenuate = vec3(0.0,0.0,0.0);\r\n    for(int i = 0; i < 2; i++) {\r\n        float fHeight = length(v3SamplePoint);\r\n        float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\r\n        float fScatter = fDepth*fTemp - fCameraOffset;\r\n        v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\r\n        v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\r\n        v3SamplePoint += v3SampleRay;\r\n    }\r\n    AtmosphereColor color;\r\n    color.mie = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\r\n    color.rayleigh = v3Attenuate;\r\n    return color;\r\n}\r\n\r\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor) {\r\n    float scalar = distanceToCamera * czm_fogDensity;\r\n    float fog = 1.0 - exp(-(scalar * scalar));\r\n    return mix(color, fogColor, fog);\r\n}\r\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant) {\r\n    float scalar = distanceToCamera * czm_fogDensity;\r\n    float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\r\n    return mix(color, fogColor, fog);\r\n}\r\n\r\nvec4 czm_FilterColor(vec4 finalColor) {\r\n    vec4 finalColor1 = vec4(0);\r\n    if(grayFilterEnable) {\r\n        float gray = clamp( dot( finalColor.rgb, vec3(0.333, 0.333, 0.333) ), 0.0, 1.0 );\r\n        finalColor1.rgb = texture2D( colorMapping, vec2( gray, 0.5 ) ).rgb;\r\n        finalColor1.a = finalColor.a;\r\n    } else {\r\n        finalColor1 = finalColor;\r\n    }\r\n    return finalColor1;\r\n}\r\nvoid main() {\r\n    #include <logdepthbuf_fragment>\r\n    //vec2 texCoords =  vec2( gl_TexCoord[0] );\r\n    vec2 webglUv = texCoords;\r\n    //webglUv.y =1.0 - webglUv.y;\r\n    webglUv = clamp(webglUv , 0.0, 1.0);\r\n    vec4 lastColor = sampleAndBlend(isAddEffect0,earthColor0,earthAddColor0,u_initialColor,TexSampler0,webglUv,textureRectangle0,textureTransAndScale0,alphaIndex0,brightness0,south1,north1,southMercatorY1,oneOverMercatorHeight1,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\r\n    lastColor = sampleAndBlend(isAddEffect1,earthColor1,earthAddColor1,lastColor,TexSampler1,webglUv,textureRectangle1,textureTransAndScale1,alphaIndex1,brightness1,south2,north2,southMercatorY2,oneOverMercatorHeight2,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\r\n    //to caculate fog\r\n    //float cameraDist = length(viewMatrix[3]);\r\n    float cameraDist = length(cameraPosition);\r\n    float fade = czm_fade(cameraDist, fadeInDist, fadeOutDist);\r\n\r\n    //added lambertDiffuse TODO is it effective? \u8fd9\u4e2a\u5f88\u4e00\u822c\uff0c\u5148\u5ffd\u7565\u5427\uff0c\u6bd5\u7adf\u54b1\u4eec\u6027\u80fd\u4e0d\u592a\u597d\u554a\r\n    //float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_sunDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\r\n    //diffuseIntensity = mix(1.0, diffuseIntensity, fade);\r\n    //vec4 finalColor = vec4(color.rgb * diffuseIntensity, color.a);\r\n    vec4 finalColor = lastColor;\r\n    //added fogColor and hdr\r\n    AtmosphereColor atmosFogColor = computeGroundAtmosphereFromSpace(PositionWS, false);\r\n    vec3 c0 = atmosFogColor.mie;\r\n    vec3 c1 = atmosFogColor.rayleigh;\r\n    vec3 fogColor1 = c0 + finalColor.rgb * c1;\r\n    //we should use hdr\r\n    const float fExposure = 2.0;\r\n    fogColor1 = vec3(1.0) - exp(-fExposure * fogColor1);\r\n\r\n    //fog added\r\n    //const float modifier = 0.15;\r\n    //finalColor = vec4(czm_fog(length(ModelPostion), finalColor.rgb, fogColor), finalColor.a);\r\n    finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor1), finalColor.a);\r\n\r\n    //ground\r\n    //SUN \u8fd9\u4e2asun\u7684\u8ba1\u7b97\u5904\u7406\u4e86\u4e0b\uff0c\u6211\u4eec\u4e0d\u80fd\u548ccesium\u7528\u4e00\u6837\u7684\u53c2\u6570\uff0c\u8fd9\u6837\u53ef\u80fd\u65e0\u6cd5\u6a21\u62df\u771f\u5b9e\u592a\u9633\u7684\u4f4d\u7f6e\r\n    vec3 groundAtmosphereColor = vec3(0.0);\r\n    if(night == 1.0){\r\n        AtmosphereColor atmosColor = computeGroundAtmosphereFromSpace(PositionWS, true);\r\n        groundAtmosphereColor = atmosColor.mie + finalColor.rgb * atmosColor.rayleigh;\r\n        groundAtmosphereColor = vec3(1.0) - exp(-fExposure * groundAtmosphereColor);\r\n        //TODO \u8fd9\u4e2a\u53ef\u80fd\u8981\u5f31\u4e00\u70b9\u624d\u884c\r\n        float sunlitAtmosphereIntensity = clamp((cameraDist - nightfadeOut) / (nightfadeIn - nightfadeOut), 0.0, 1.0);//caculate sun\r\n        // used hdr to make HDR look better\r\n        sunlitAtmosphereIntensity = max(sunlitAtmosphereIntensity * sunlitAtmosphereIntensity, 0.03);\r\n        //mix sun\r\n        groundAtmosphereColor = mix(groundAtmosphereColor, fogColor1, sunlitAtmosphereIntensity);\r\n    } else {\r\n        groundAtmosphereColor = fogColor1;\r\n    }\r\n    //use saturation to look better\r\n    groundAtmosphereColor = czm_saturation(groundAtmosphereColor, 1.6);\r\n    //mix\r\n    finalColor = vec4(mix(finalColor.rgb, groundAtmosphereColor, fade), finalColor.a);\r\n    finalColor.rgb *= vec3(earthColor0.a);\r\n    //finally you get the color\r\n    finalColor = czm_FilterColor(finalColor);\r\n    gl_FragColor = finalColor;\r\n    //now we get the shadow\r\n    //gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), (1.0-getShadowMask()));\r\n    vec4 shadow = vec4(vec3(0.0), shadowOpacity * ( 1.0 - getShadowMask() ) );\r\n    gl_FragColor.rgb = mix(gl_FragColor.rgb, shadow.rgb, shadow.a);\r\n    #include <fog_fragment>\r\n}"},753:function(e,t){e.exports="//varying vec4 Position;\r\n//precision highp float;\r\n#include <common>\r\n#include <packing>\r\n#include <fog_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <shadowmap_pars_fragment>\r\n#include <shadowmask_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n//varying vec3 ModelPostion;\r\nvarying float v_distance;\r\nvarying vec3 PositionWS;\r\nvarying vec2 texCoords;\r\n\r\nuniform bool grayFilterEnable;\r\nuniform float shadowOpacity;\r\n//uniform float grayMinMax[2];\r\n//uniform float grayFilterPerBar[10];\r\n//uniform vec3 grayFilterColorBar[10];\r\n\r\nuniform sampler2D TexSampler0;\r\nuniform sampler2D TexSampler1;\r\nuniform sampler2D TexSampler2;\r\n\r\nuniform\tvec4 textureRectangle0;\r\nuniform\tvec4 textureRectangle1;\r\nuniform\tvec4 textureRectangle2;\r\n\r\nuniform\tvec4 textureTransAndScale0;\r\nuniform\tvec4 textureTransAndScale1;\r\nuniform\tvec4 textureTransAndScale2;\r\n\r\nuniform float brightness0;\r\nuniform float brightness1;\r\nuniform float brightness2;\r\n\r\nuniform float alphaIndex0;\r\nuniform float alphaIndex1;\r\nuniform float alphaIndex2;\r\n\r\nuniform float isAddEffect0;\r\nuniform float isAddEffect1;\r\nuniform float isAddEffect2;\r\n\r\n\r\nuniform vec4 earthColor0;\r\nuniform vec4 earthColor1;\r\nuniform vec4 earthColor2;\r\n\r\nuniform vec4 earthAddColor0;\r\nuniform vec4 earthAddColor1;\r\nuniform vec4 earthAddColor2;\r\n\r\nuniform float south1;\r\nuniform float north1;\r\nuniform float southMercatorY1;\r\nuniform float oneOverMercatorHeight1;\r\nuniform float isReProjection;\r\n\r\nuniform float south2;\r\nuniform float north2;\r\nuniform float southMercatorY2;\r\nuniform float oneOverMercatorHeight2;\r\n\r\nuniform float south3;\r\nuniform float north3;\r\nuniform float southMercatorY3;\r\nuniform float oneOverMercatorHeight3;\r\n\r\nuniform\tfloat Km;\r\nuniform\tfloat Kr;\r\nuniform\tfloat ESun;\r\n\r\nuniform int nSamples;\r\nuniform float fSamples;\r\n\r\n//uniform float g,\r\n\r\n//uniform\tvec3 v3CameraPosInput;\r\nuniform\tvec3 v3LightPosInput;\r\n\r\nuniform\tfloat fInnerRadius;\r\nuniform\tfloat fOuterRadius;\r\n\r\nuniform float fScaleDepth;\r\nuniform\tvec4 inputColor;\r\nuniform vec4 alphaValue;\r\nuniform float night;\r\n\r\nuniform float contrast;\r\nuniform float hue;\r\nuniform float saturation;\r\nuniform float textureGamma;\r\n//uniform vec4 earthColor;\r\n//uniform vec4 earthAddColor;\r\n//uniform float isAddEffect;\r\n\r\nuniform vec4 u_initialColor;\r\nuniform float nightfadeIn;\r\nuniform float nightfadeOut;\r\nuniform float fadeInDist;\r\nuniform float fadeOutDist;\r\n\r\nuniform float czm_fogDensity;\r\nuniform sampler2D colorMapping;\r\n//#define saturate(a) clamp( a, 0.0, 1.0 )\r\n//#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n//#define LOG2 1.442695\r\n\r\nstruct czm_ellipsoid {\r\n    vec3 center;\r\n    vec3 radii;\r\n    vec3 inverseRadii;\r\n    vec3 inverseRadiiSquared;\r\n};\r\nstruct AtmosphereColor {\r\n    vec3 mie;\r\n    vec3 rayleigh;\r\n};\r\n\r\n//\u641e\u5b9a\r\nfloat scale(float fCos, float fScaleDepth) {\r\n    float x = 1.0 - fCos;\r\n    return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\r\n}\r\nvec4 depthColor(vec4 color) {\r\n    color.r = color.r * color.r * color.r;\r\n    color.g = color.g * color.g * color.g;\r\n    color.b = color.b * color.b;\r\n    return color;\r\n}\r\n//\u641e\u5b9a\r\n// Returns the near intersection point of a line and a sphere\r\nfloat getNearIntersection(vec3 v3Pos, vec3 v3Ray, float fDistance2, float fRadius2) {\r\n    float B = 2.0 * dot(v3Pos, v3Ray);\r\n    float C = fDistance2 - fRadius2;\r\n    float fDet = max(0.0, B*B - 4.0 * C);\r\n    return 0.5 * (-B - sqrt(fDet));\r\n}\r\n\r\nvec3 czm_contrast(vec3 rgb, float contrast) {\r\n    vec3 color = mix(vec3(0.5), rgb, contrast);\r\n    color = clamp(color, 0.0, 1.0);\r\n    return color;\r\n}\r\n\r\nvec3 czm_hue(vec3 rgb, float adjustment) {\r\n    const mat3 toYIQ = mat3(0.299, 0.587, 0.114,\r\n                            0.595716, -0.274453, -0.321263,\r\n                            0.211456, -0.522591, 0.311135);\r\n    const mat3 toRGB = mat3(1.0, 0.9563, 0.6210,\r\n                            1.0, -0.2721, -0.6474,\r\n                            1.0, -1.107, 1.7046);\r\n    vec3 yiq = toYIQ * rgb;\r\n    float hue = atan(yiq.z, yiq.y) + adjustment;\r\n    float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\r\n    vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\r\n    vec3 final = toRGB * color;\r\n    final = clamp(final, 0.0, 1.0);\r\n    return final;\r\n}\r\n\r\nvec3 czm_saturation(vec3 rgb, float adjustment) {\r\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\r\n    vec3 intensity = vec3(dot(rgb, W));\r\n    vec3 color = mix(intensity, rgb, adjustment);\r\n    color = clamp(color, 0.0, 1.0);\r\n    return color;\r\n}\r\n\r\nvec4 sampleAndBlend(\r\n    float addEffect,\r\n    vec4 eColor,\r\n    vec4 addColor,\r\n    vec4 previousColor,\r\n    sampler2D sampler_texture,\r\n    vec2 tileTextureCoordinates,\r\n    vec4 textureCoordinateRectangle,\r\n    vec4 textureCoordinateTranslationAndScale,\r\n    float textureAlphaIndex,\r\n    float brightness,\r\n    float south,\r\n    float north,\r\n    float southMercatorY,\r\n    float oneOverMercatorHeight,\r\n    float isReProjection,\r\n    vec4 alphaValue,\r\n    float contrast,\r\n    float hue,\r\n    float saturation,\r\n    float gamma\r\n) {\r\n    float textureAlpha = 1.0;\r\n\r\n    vec2 alphaMultiplier = step(textureCoordinateRectangle.xy, tileTextureCoordinates);\r\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\r\n\r\n    alphaMultiplier = step(vec2(0.0,0.0), textureCoordinateRectangle.zw - tileTextureCoordinates);\r\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\r\n\r\n    vec2 translation = textureCoordinateTranslationAndScale.xy;\r\n    vec2 scale = textureCoordinateTranslationAndScale.zw;\r\n    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\r\n\r\n    //\u518d\u6295\u5f71\r\n    float latitude = mix(south, north, textureCoordinates.y);\r\n    float sinLatitude = sin(latitude);\r\n    float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\r\n    float mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;\r\n    textureCoordinates.y = mercatorFraction;\r\n\r\n    if(isReProjection == 0.0) {\r\n        textureCoordinates.y = (tileTextureCoordinates * scale + translation).y;\r\n    }\r\n\r\n    //textureCoordinates = clamp(textureCoordinates, 1.0/256.0, 255.0/256.0);\r\n    vec4 value = texture2D(sampler_texture, textureCoordinates);\r\n    if(addEffect == 1.0){\r\n        value = depthColor(value);\r\n    }\r\n    value.rgb *= eColor.rgb;\r\n//          if(eColor.a==1.0){\r\n//                value *=eColor;\r\n//              }\r\n//              else{\r\n//                //value.rgb = (value.rgb + eColor.rgb * eColor.a)/(1.0 + eColor.a);\r\n//                 value.rgb = value.rgb * (1.0-eColor.a) + eColor.rgb * eColor.a;\r\n//              }\r\n    value.rgb = (value.rgb + addColor.rgb * addColor.a)/(1.0 + addColor.a);\r\n    vec3 color = value.rgb;\r\n    float alpha = value.a;\r\n\r\n    color = mix(vec3(0.0,0.0,0.0), color, brightness);\r\n    //contrast\r\n    color = czm_contrast(color, contrast);\r\n    //hue\r\n    color = czm_hue(color, hue);\r\n    // saturation\r\n    color = czm_saturation(color, saturation);\r\n    // gamma\r\n    color = pow(color, vec3(gamma));\r\n\r\n    float sourceAlpha = alpha * textureAlpha;\r\n    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\r\n    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\r\n    return vec4(outColor, outAlpha);\r\n}\r\n\r\n//czm_ellipsoid czm_getWgs84EllipsoidEC()\r\n//{\r\n//    vec3 radii = vec3(6378137.0, 6378137.0, 6356752.314245);\r\n//    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\r\n//    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\r\n//    czm_ellipsoid temp = czm_ellipsoid(viewMatrix[3].xyz, radii, inverseRadii, inverseRadiiSquared);\r\n//    return temp;\r\n//}\r\nfloat czm_fade(float cameraDist, float fadeInDist, float fadeOutDist) {\r\n    float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\r\n    return fade;\r\n}\r\nAtmosphereColor computeGroundAtmosphereFromSpace(vec3 v3Pos, bool useSunLighting) {\r\n    //float PI = 3.14159265;\r\n    //float g2 =  g * g;\r\n\r\n    vec3 v3InvWavelength = vec3(1.0 / pow(0.650, 4.0), 1.0 / pow(0.570, 4.0), 1.0 / pow(0.475, 4.0));\r\n\r\n    vec3 v3CameraPos =  vec3(0.0, 0.0, 0.0);\r\n    v3CameraPos = cameraPosition;\r\n\r\n    vec3 v3LightPos = v3LightPosInput / length(v3LightPosInput);\r\n\r\n    float fCameraHeight = length(v3CameraPos);\r\n\r\n    float fCameraHeight2 = fCameraHeight * fCameraHeight;\r\n\r\n    float inOutFactor = 1.05;\r\n    float fInnerRadius2 = fInnerRadius * fInnerRadius;\r\n    float fOuterRadius2 = fOuterRadius * fOuterRadius;\r\n\r\n    float fKrESun = Kr * ESun;\r\n    float fKmESun = Km * ESun;\r\n    float fKr4PI = Kr * 4.0 * PI;\r\n    float fKm4PI = Km * 4.0 * PI;\r\n\r\n    float fInvScaleDepth = 1.0 / fScaleDepth;\r\n    float fScale = 1.0 / (fOuterRadius - fInnerRadius);\r\n    float fScaleOverScaleDepth = fScale / fScaleDepth;\r\n\r\n    ////////////////////////////////////////////////\r\n    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\r\n    //vec3 v3Pos = PositionWS;\r\n    vec3 v3Ray = v3Pos - v3CameraPos;\r\n    v3Pos = normalize(v3Pos);\r\n    float fFar = length(v3Ray);\r\n    v3Ray /= fFar;\r\n    // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\r\n    float fNear = getNearIntersection(v3CameraPos, v3Ray, fCameraHeight2, fOuterRadius2);\r\n    // Calculate the ray's starting position, then calculate its scattering offset\r\n    vec3 v3Start = v3CameraPos + v3Ray * fNear;\r\n    fFar -= fNear;\r\n    float fDepth = exp((fInnerRadius - fOuterRadius) * fInvScaleDepth);\r\n\r\n    //if you donnot want night make it 1.0\r\n    float fLightAngle = useSunLighting ? dot(v3LightPos, v3Pos) / length(v3Pos) : 1.0;\r\n    float fCameraAngle = dot(-v3Ray, v3Pos)/length(v3Pos);\r\n    //float fLightAngle = dot(v3LightPos, v3Pos);\r\n    float fCameraScale = scale(fCameraAngle, fScaleDepth);\r\n    float fLightScale = scale(fLightAngle, fScaleDepth);\r\n    float fCameraOffset = fDepth*fCameraScale;\r\n    float fTemp = (fLightScale + fCameraScale);\r\n    // Initialize the scattering loop variables\r\n    //gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);\r\n    float fSampleLength = fFar / fSamples;\r\n    float fScaledLength = fSampleLength * fScale;\r\n    vec3 v3SampleRay = v3Ray * fSampleLength;\r\n    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\r\n    // Now loop through the sample rays\r\n    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\r\n    vec3 v3Attenuate = vec3(0.0,0.0,0.0);\r\n    for(int i = 0; i < 2; i++) {\r\n        float fHeight = length(v3SamplePoint);\r\n        float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\r\n        float fScatter = fDepth*fTemp - fCameraOffset;\r\n        v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\r\n        v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\r\n        v3SamplePoint += v3SampleRay;\r\n    }\r\n    AtmosphereColor color;\r\n    color.mie = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\r\n    color.rayleigh = v3Attenuate;\r\n    return color;\r\n}\r\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor) {\r\n    float scalar = distanceToCamera * czm_fogDensity;\r\n    float fog = 1.0 - exp(-(scalar * scalar));\r\n    return mix(color, fogColor, fog);\r\n}\r\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant) {\r\n    float scalar = distanceToCamera * czm_fogDensity;\r\n    float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\r\n    return mix(color, fogColor, fog);\r\n}\r\n\r\nvec4 czm_FilterColor(vec4 finalColor) {\r\n    vec4 finalColor1 = vec4(0);\r\n    if(grayFilterEnable) {\r\n        float gray = clamp( dot( finalColor.rgb, vec3(0.333, 0.333, 0.333) ), 0.0, 1.0 );\r\n        finalColor1.rgb = texture2D(colorMapping, vec2(gray, 0.5)).rgb;\r\n        finalColor1.a = finalColor.a;\r\n    } else {\r\n        finalColor1 = finalColor;\r\n    }\r\n    return finalColor1;\r\n}\r\nvoid main() {\r\n    #include <logdepthbuf_fragment>\r\n    //vec2 texCoords =  vec2( gl_TexCoord[0] );\r\n    vec2 webglUv = texCoords;\r\n    //webglUv.y =1.0 - webglUv.y;\r\n    webglUv = clamp(webglUv , 0.0, 1.0);\r\n    vec4 lastColor = sampleAndBlend(isAddEffect0,earthColor0,earthAddColor0,u_initialColor,TexSampler0,webglUv,textureRectangle0,textureTransAndScale0,alphaIndex0,brightness0,south1,north1,southMercatorY1,oneOverMercatorHeight1,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\r\n    lastColor = sampleAndBlend(isAddEffect1,earthColor1,earthAddColor1,lastColor,TexSampler1,webglUv,textureRectangle1,textureTransAndScale1,alphaIndex1,brightness1,south2,north2,southMercatorY2,oneOverMercatorHeight2,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\r\n    lastColor = sampleAndBlend(isAddEffect2,earthColor2,earthAddColor2,lastColor,TexSampler2,webglUv,textureRectangle2,textureTransAndScale2,alphaIndex2,brightness2,south3,north3,southMercatorY3,oneOverMercatorHeight3,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\r\n    //to caculate fog\r\n    //float cameraDist = length(viewMatrix[3]);\r\n    float cameraDist = length(cameraPosition);\r\n    float fade = czm_fade(cameraDist, fadeInDist, fadeOutDist);\r\n\r\n    //added lambertDiffuse TODO is it effective? \u8fd9\u4e2a\u5f88\u4e00\u822c\uff0c\u5148\u5ffd\u7565\u5427\uff0c\u6bd5\u7adf\u54b1\u4eec\u6027\u80fd\u4e0d\u592a\u597d\u554a\r\n    //float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_sunDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\r\n    //diffuseIntensity = mix(1.0, diffuseIntensity, fade);\r\n    //vec4 finalColor = vec4(color.rgb * diffuseIntensity, color.a);\r\n    vec4 finalColor = lastColor;\r\n    //added fogColor and hdr\r\n    //added fogColor and hdr\r\n    AtmosphereColor atmosFogColor = computeGroundAtmosphereFromSpace(PositionWS, false);\r\n    vec3 c0 = atmosFogColor.mie;\r\n    vec3 c1 = atmosFogColor.rayleigh;\r\n    vec3 fogColor1 = c0 + finalColor.rgb * c1;\r\n    //we should use hdr\r\n    const float fExposure = 2.0;\r\n    fogColor1 = vec3(1.0) - exp(-fExposure * fogColor1);\r\n\r\n    //fog added\r\n    // const float modifier = 0.15;\r\n    finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor1), finalColor.a);\r\n\r\n    //ground\r\n    //SUN \u8fd9\u4e2asun\u7684\u8ba1\u7b97\u5904\u7406\u4e86\u4e0b\uff0c\u6211\u4eec\u4e0d\u80fd\u548ccesium\u7528\u4e00\u6837\u7684\u53c2\u6570\uff0c\u8fd9\u6837\u53ef\u80fd\u65e0\u6cd5\u6a21\u62df\u771f\u5b9e\u592a\u9633\u7684\u4f4d\u7f6e\r\n    vec3 groundAtmosphereColor = vec3(0.0);\r\n    if(night == 1.0) {\r\n        AtmosphereColor atmosColor = computeGroundAtmosphereFromSpace(PositionWS, true);\r\n        groundAtmosphereColor = atmosColor.mie + finalColor.rgb * atmosColor.rayleigh;\r\n        groundAtmosphereColor = vec3(1.0) - exp(-fExposure * groundAtmosphereColor);\r\n        //TODO \u8fd9\u4e2a\u53ef\u80fd\u8981\u5f31\u4e00\u70b9\u624d\u884c\r\n        float sunlitAtmosphereIntensity = clamp((cameraDist - nightfadeOut) / (nightfadeIn - nightfadeOut), 0.0, 1.0);//caculate sun\r\n        // used hdr to make HDR look better\r\n        sunlitAtmosphereIntensity = max(sunlitAtmosphereIntensity * sunlitAtmosphereIntensity, 0.03);\r\n        //mix sun\r\n        groundAtmosphereColor = mix(groundAtmosphereColor, fogColor1, sunlitAtmosphereIntensity);\r\n    } else{\r\n        groundAtmosphereColor = fogColor1;\r\n    }\r\n    //use saturation to look better\r\n    groundAtmosphereColor = czm_saturation(groundAtmosphereColor, 1.6);\r\n    //mix\r\n    finalColor = vec4(mix(finalColor.rgb, groundAtmosphereColor, fade), finalColor.a);\r\n    finalColor.rgb *= vec3(earthColor0.a);\r\n    //finally you get the color\r\n    finalColor = czm_FilterColor(finalColor);\r\n    gl_FragColor = finalColor;\r\n    //now we get the shadow\r\n    //gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), (1.0-getShadowMask()));\r\n    vec4 shadow = vec4(vec3(0.0), shadowOpacity * ( 1.0 - getShadowMask() ) );\r\n    gl_FragColor.rgb = mix(gl_FragColor.rgb, shadow.rgb, shadow.a);\r\n    #include <fog_fragment>\r\n}"},754:function(e,t,r){var n={"./BuildingLayer":439,"./BuildingLayer.js":439,"./LabelLayer":440,"./LabelLayer.js":440,"./Layer":162,"./Layer.js":162,"./LineLayer":441,"./LineLayer.js":441,"./PointLayer":442,"./PointLayer.js":442,"./PolygonLayer":443,"./PolygonLayer.js":443,"./ScanLayer":444,"./ScanLayer.js":444};function o(e){var t=a(e);return r(t)}function a(e){if(!r.o(n,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return n[e]}o.keys=function(){return Object.keys(n)},o.resolve=a,e.exports=o,o.id=754},768:function(e,t,r){"use strict";r.r(t),r.d(t,"default",(function(){return _}));var n=r(19),o=r(20),a=r(44),i=r(45),s=r(326),l=r(139),c=r(327),u=r.n(c),h=r(751),f=r.n(h),d=function(){var e={fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new a.Color(16777215)},fogAlpha:{value:1},grayFilterEnable:{value:!1},colorMapping:{value:null},TexSampler0:{value:{}},textureRectangle0:{value:new a.Vector4(0,0,0,0)},textureTransAndScale0:{value:new a.Vector4(0,0,0,0)},alphaIndex0:{value:1},brightness0:{value:1},Km:{value:.0025},Kr:{value:.0015},ESun:{value:10},nSamples:{value:2},fSamples:{value:2},v3LightPosInput:{value:new a.Vector3(20,20,20)},fInnerRadius:{value:1},fOuterRadius:{value:1.05},fScaleDepth:{value:.25},v3CameraPosInput:{value:new a.Vector3(0,0,0)},south1:{value:0},north1:{value:0},southMercatorY1:{value:0},oneOverMercatorHeight1:{value:0},isReProjection:{value:0},objectPos:{value:new a.Vector4(0,0,0,0)},inputColor:{value:new a.Vector4(1,0,0,0)},alphaValue:{value:new a.Vector4(1,0,0,0)},isAddEffect0:{value:0},earthColor0:{value:new a.Vector4(1,1,1,1)},earthAddColor0:{value:new a.Vector4(0,0,0,0)},night:{value:1},contrast:{value:1},hue:{value:0},saturation:{value:1},textureGamma:{value:1},nightfadeIn:{value:25e6},nightfadeOut:{value:1e7},fadeInDist:{value:15e6},fadeOutDist:{value:1e7},u_initialColor:{value:new a.Vector4(0,0,0,1)},czm_fogDensity:{value:1e-4},shadowOpacity:{value:.5}};return a.UniformsUtils.clone(a.UniformsUtils.merge([a.UniformsLib.lights,e]))},m=d(),v=new a.ShaderMaterial({uniforms:m,vertexShader:u.a,fragmentShader:f.a});v.fog=!0,v.lights=!0;var p=v,g=r(752),y=r.n(g),C=d();C.TexSampler1={value:{}},C.alphaIndex1={value:1},C.textureRectangle1={value:new a.Vector4(0,0,0,0)},C.textureTransAndScale1={value:new a.Vector4(0,0,0,0)},C.brightness1={value:1},C.isAddEffect1={value:0},C.earthColor1={value:new a.Vector4(1,1,1,1)},C.earthAddColor0={value:new a.Vector4(0,0,0,0)},C.south2={value:0},C.north2={value:0},C.southMercatorY2={value:0},C.oneOverMercatorHeight2={value:0};var x=new a.ShaderMaterial({uniforms:C,vertexShader:u.a,fragmentShader:y.a});x.fog=!0,x.lights=!0;var b=x,w=r(753),S=r.n(w),P=d();P.TexSampler1={value:{}},P.TexSampler2={value:{}},P.alphaIndex1={value:1},P.alphaIndex2={value:1},P.textureRectangle1={value:new a.Vector4(0,0,0,0)},P.textureRectangle2={value:new a.Vector4(0,0,0,0)},P.textureTransAndScale1={value:new a.Vector4(0,0,0,0)},P.textureTransAndScale2={value:new a.Vector4(0,0,0,0)},P.brightness1={value:1},P.brightness2={value:1},P.isAddEffect1={value:0},P.isAddEffect2={value:0},P.earthColor1={value:new a.Vector4(1,1,1,1)},P.earthColor2={value:new a.Vector4(1,1,1,1)},P.earthAddColor1={value:new a.Vector4(0,0,0,0)},P.earthAddColor2={value:new a.Vector4(0,0,0,0)},P.south2={value:0},P.north2={value:0},P.southMercatorY2={value:0},P.oneOverMercatorHeight2={value:0},P.south3={value:0},P.north3={value:0},P.southMercatorY3={value:0},P.oneOverMercatorHeight3={value:0};var M=new a.ShaderMaterial({uniforms:P,vertexShader:u.a,fragmentShader:S.a});M.fog=!0,M.lights=!0;var A=M;i.__Custom||(i.__Custom={},i.__Custom.ImageryReleaseReference=function(e){null!==e.image&&void 0!==e.image&&s.a.delete("textureBuffer",e.image.name),null!==e.texture&&void 0!==e.texture&&e.texture.dispose()},i.__Custom.ImageryLayerCreateTexture=function(e){var t=e.image,r=t.src;t.name=encodeURI(r);var n=s.a.get("textureBuffer",t.name);n?e.texture=n:((n=new a.Texture(t)).needsUpdate=!0,s.a.save("textureBuffer",t.name,n),e.texture=n,n=null)},i.__Custom.TileReplacementQueueTrimTiles=function(e){var t="EarthTile_".concat(e._level,"_").concat(e._x,"_").concat(e._y),r=s.a.get("nodeBuffer",t);if(r){var n=r.materialName;s.a.get("tileMaterialBuffer",n).dispose(),s.a.delete("tileMaterialBuffer",n),s.a.delete("nodeBuffer",t)}});var _=function(){function e(t){Object(n.a)(this,e),this.sceneType={Scene_2D:0,Scene_3D:1},this.cssFilter="sepia(100%) invert(90%)",this.radius=l.a.radius,this.globeMaterials=[p,b,A],this.textureRectangles=["textureRectangle0","textureRectangle1","textureRectangle2","textureRectangle3","textureRectangle4","textureRectangle5"],this.textureTransAndScales=["textureTransAndScale0","textureTransAndScale1","textureTransAndScale2","textureTransAndScale3","textureTransAndScale4","textureTransAndScale5"],this.alphaIndexs=["alphaIndex0","alphaIndex1","alphaIndex2","alphaIndex3","alphaIndex4","alphaIndex5"],this.souths=["south1","south2","south3","south4","south5","south6"],this.norths=["north1","north2","north3","north4","north5","north6"],this.southMercatorYs=["southMercatorY1","southMercatorY2","southMercatorY3","southMercatorY4","southMercatorY5","southMercatorY6"],this.oneOverMercatorHeights=["oneOverMercatorHeight1","oneOverMercatorHeight2","oneOverMercatorHeight3","oneOverMercatorHeight4","oneOverMercatorHeight5","oneOverMercatorHeight6"],this.brightnesses=["brightness0","brightness1","brightness2","brightness3","brightness4","brightness5"],this.addEffects=["isAddEffect0","isAddEffect1","isAddEffect2","isAddEffect3","isAddEffect4","isAddEffect5"],this.earthColors=["earthColor0","earthColor1","earthColor2","earthColor3","earthColor4","earthColor5"],this.mode=this.sceneType.Scene_3D;var r=new a.Color(16777215);this.color=[r.r,r.g,r.b,1],this.quadTileMatrial={},this.quadTileRelativePos={},this._recorder=function(){var e=[];return{push:function(t){return e.length>=2&&e.shift(),e.push(t),e},get:function(){return e},clear:function(){e.splice(0,e.length)}}}(),this.quadTileRadius={},this.quadTileEncode={},Object.assign(this,t),this.init()}return Object(o.a)(e,[{key:"init",value:function(){this.curOrbit=this.view.curOrbit,this.camera=this.view._camera,this.node.name="tileEarth",s.a.save("nodeBuffer","tiles-root",this.node),this.dirty=!1,this.materialDirty=!1,this.tileCacheSize=100,this._imageryLayerCollection=new i.ImageryLayerCollection,this.mapProjection=new i.GeographicProjection,this._terrainProvider=new i.EllipsoidTerrainProvider({ellipsoid:this.mapProjection.ellipsoid}),this._frameState=new i.FrameState,this._frameState.passes.render=!0,this._frameState.frameNumber=0,this._frameState.cameraPos=new i.Cartesian3,this._frameState.positionCartographic=new i.Cartographic,this._frameState.perspectiveOffCenterFrustum=new i.PerspectiveOffCenterFrustum,this._surfaceShaderSet=new i.GlobeSurfaceShaderSet,this._surface=new i.QuadtreePrimitive({tileProvider:new i.GlobeSurfaceTileProvider({terrainProvider:this._terrainProvider,imageryLayers:this._imageryLayerCollection,surfaceShaderSet:this._surfaceShaderSet}),tileCacheSize:this.tileCacheSize}),a.ImageUtils.crossOrigin="anonymous",this.setMap({url:this.url}),this.goHome()}},{key:"clear",value:function(){}},{key:"setMap",value:function(e){this.addImageryLayer(e),e.color&&this.setStyle({color:l.a.getColor(e.color)})}},{key:"goHome",value:function(){this.camera.setPosition([4890109.86328125,9295980.46875,13943610.3515625]),this.camera.lookAt(0,0,0),this.curOrbit.goHome()}},{key:"changeStyle",value:function(){this.dirty=!0,this.materialDirty=!0;var e=s.a.getAll("tileMaterialBuffer");for(var t in e)e[t]._tileNeedUpdate=!0}},{key:"addImageryLayer",value:function(e){var t=new i.OpenStreetMapImageryProvider(e),r=t._resource._url,n=r.indexOf("{"),o=r.indexOf("}");if(n>0&&o>n){var a=r.substring(n+1,o);if(!["x","y","z","level"].includes(a)){var s=a.split(",");t._resource._url=r.replace(a,"s"),t._subdomains=s}}if(this._imageryLayerCollection.length>0)for(var l=0;l<this._imageryLayerCollection.length;l++){var c=this._imageryLayerCollection.get(l);if(c._imageryProvider.url.indexOf(t._resource._url)>=0)return;this._imageryLayerCollection.remove(c,!0),this._imageryLayerCollection.addImageryProvider(t,l),this.changeStyle()}else this._imageryLayerCollection.addImageryProvider(t),this.changeStyle()}},{key:"setStyle",value:function(e){var t=e.color;this.color=t,this.changeStyle()}},{key:"getFov",value:function(e,t){return 90}},{key:"getFrameState",value:function(e,t){var r=e.cameraPos,n=e.viewPort,o=e.fov,a=e.cameraDirection,s=e.cameraUp,l=this._frameState;l.cameraPos.x=r[0],l.cameraPos.y=-r[2],l.cameraPos.z=r[1];var c=new i.Cartesian3,u=new i.Cartesian3,h=new i.Cartesian3;if(t==this.sceneType.Scene_3D)l.mapProjection=new i.GeographicProjection,c.x=-r[0],c.y=r[2],c.z=r[1],l.positionCartographic=l.mapProjection.ellipsoid.cartesianToCartographic(l.cameraPos),u.x=-a[0],u.y=a[2],u.z=a[1],h.x=-s[0],h.y=s[2],h.z=s[1],l.mode=i.SceneMode.SCENE3D;else if(t==this.sceneType.Scene_2D){l.mapProjection=new i.WebMercatorProjection,c.x=r[1],c.y=r[0],c.z=-r[2];var f=new i.Cartesian3;f.x=r[0],f.y=-r[2],f.z=r[1],l.positionCartographic=l.mapProjection.unproject(f),u.x=a[1],u.y=a[0],u.z=-a[2],h.x=s[1],h.y=s[0],h.z=-s[2],l.mode=i.SceneMode.COLUMBUS_VIEW}l.positionWC=c;var d,m=n.actualWidth,v=n.actualHeight,p=m/v;l.drawWidth=m,l.drawHeight=v,o=this.getFov(p,o),o=Math.PI*o/180,d=p<=1?o:2*Math.atan(Math.tan(.5*o)/p),l.fov=o,l.fovy=d,l.aspectRatio=p,l.sseDenominator=2*Math.tan(.5*d),l.perspectiveOffCenterFrustum.near=1,l.perspectiveOffCenterFrustum.far=5e8,l.perspectiveOffCenterFrustum.top=1*Math.tan(.5*d),l.perspectiveOffCenterFrustum.sseDenominator=l.sseDenominator,l.perspectiveOffCenterFrustum.bottom=-l.perspectiveOffCenterFrustum.top,l.perspectiveOffCenterFrustum.right=p*l.perspectiveOffCenterFrustum.top,l.perspectiveOffCenterFrustum.left=-l.perspectiveOffCenterFrustum.right,l.directionWC=u,l.upWC=h,l.cullingVolume=l.perspectiveOffCenterFrustum.computeCullingVolume(l.positionWC,u,h),l.context={},l.frameNumber=i.Math.incrementWrap(l.frameNumber,15e6,1),l.afterRender=[],l.camera={positionWC:l.positionWC,positionCartographic:l.positionCartographic,directionWC:l.directionWC,frustum:l.perspectiveOffCenterFrustum},l.context.drawingBufferWidth=l.drawWidth,l.context.drawingBufferHeight=l.drawHeight,l.shadowState.shadowsEnabled=!1}},{key:"updateCamera",value:function(){var e,t=this.camera.getPosition();this.mode===this.sceneType.Scene_2D?e=t[1]:this.mode===this.sceneType.Scene_3D&&(e=l.a.vectorDistance([0,0,0],t),e-=this.radius),this.camera.setFarClipDistance(5e7),e>1e4&&e<=1e5?this.camera.setNearClipDistance(100):e>1e3&&e<=1e4?this.camera.setNearClipDistance(10):e>100&&e<=1e3?this.camera.setNearClipDistance(1):e>1&&e<=100?this.camera.setNearClipDistance(.1):e<=1?this.camera.setNearClipDistance(.01):this.camera.setNearClipDistance(e/20)}},{key:"update",value:function(){if(this.updateCamera(),this.curOrbit.update(),this._imageryLayerCollection.length>0){var e={cameraPos:this.camera.getPosition(),viewPort:this.camera.getViewport(),fov:this.camera.getFov(),cameraDirection:this.camera.getDirection(),cameraUp:this.camera.getUp()};this.getFrameState(e,this.mode),this._surface.beginFrame(this._frameState),this._surface.render(this._frameState),i.RequestScheduler.update(),this._surface.endFrame(this._frameState),this.draw(this._surface.tileProvider._tilesToRenderByTextureCount)}}},{key:"draw",value:function(e){if(this.isRender(e)||this.dirty){this.node.children.length=0;for(var t=0;t<e.length;t++){var r=e[t];if(void 0!==r&&null!==r)for(var n=0;n<r.length;n++){var o=void 0,a=void 0,i="",s="",l="",c=r[n];if(c.data.terrainData&&void 0!==(o=c.data.terrainData._mesh)&&null!==o){a=c.data.imagery,s=l=(i=this.tileNameCreater(c))+"--"+o.boundingSphere3D.radius,this.mode===this.sceneType.Scene_2D&&(l+="_p");var u=this.isNeedUpdate(this.quadTileRadius[i],o,i);this.quadTileMatrial[i]||(this.quadTileMatrial[i]={}),this.quadTileMatrial[i].textureCount=a.length,this.quadTileMatrial[i].textureName=[];for(var h=0;h<a.length;h++)a[h].readyImagery&&(this.quadTileMatrial[i].textureName[h]=this.createImageUrl(a[h].readyImagery));this.quadTileRadius[i]=o.boundingSphere3D.radius,u?this.updateMesh(c,i,l,s):(this.renderEarthTexure(a,i,this.quadTileRelativePos[i],this.quadTileEncode[i],s),this.cacheShow(i,s,this.node),this.renderEarthShader(a,i,this.quadTileRelativePos[i],s))}}}this.dirty=!1}}},{key:"updateMesh",value:function(e,t,r,n){var o,l=e.data.terrainData._mesh,c=e.data.imagery,u=l.vertices,h=l.indices,f=l.encoding,d=f.getStride(),m=u.length/d,v=[-l.center.x,l.center.z,l.center.y];this.quadTileRelativePos[t]=v;var p=new a.BufferGeometry;if(o=new a.InterleavedBuffer(u,d),p.setIndex(new a.BufferAttribute(h,1)),f.quantization===i.TerrainQuantization.BITS12){for(var g=new Float32Array(2*m),y=0;y<u.length/d;y++){var C,x,b,w,S,P=u[d*y]/4096,M=Math.floor(P)/4096,A=P-Math.floor(P),_=u[d*y+1]/4096;_=Math.floor(_)/4096;var O=new i.Cartesian3(M,A,_),I=new i.Cartesian3;i.Matrix4.multiplyByPoint(f.fromScaledENU,O,I),C=I.x-l.center.x,x=I.y-l.center.y,b=I.z-l.center.z;var T=u[d*y+2]/4096;w=Math.floor(T)/4096,S=T-Math.floor(T),u[y*d]=-C,u[y*d+1]=b,u[y*d+2]=x,g[2*y]=w,g[2*y+1]=S,o=new a.InterleavedBuffer(u,d)}p.setAttribute("position",new a.InterleavedBufferAttribute(o,3,0,!1)),p.setAttribute("uv",new a.BufferAttribute(g,2))}else p.setAttribute("position",new a.InterleavedBufferAttribute(o,3,0,!1)),p.setAttribute("uv",new a.InterleavedBufferAttribute(o,2,4,!1));this.renderEarthTexure(c,t,this.quadTileRelativePos[t],this.quadTileEncode[t],n),this.renderEarthShader(c,t,this.quadTileRelativePos[t],n);var z=s.a.get("tileMaterialBuffer",n),D=new a.Mesh(p,z);D.name=t,D.materialName=n,s.a.save("nodeBuffer",t,D),this.node.add(D),D.position.x=v[0],D.position.y=v[1],D.position.z=v[2],D.tile=e,l=null,u=null,h=null,f=null}},{key:"renderEarthTexure",value:function(e,t,r,n,o){var a,i=e.length,l=s.a.get("tileMaterialBuffer",o),c=this.materialDirty;(a=this.globeMaterials[i-1])&&((l=a.clone()).name="tile",s.a.save("tileMaterialBuffer",o,l),c=!0);var u=l;u.polygonOffset=!0,u.polygonOffsetFactor=1,u.polygonOffsetUnits=100;var h=t.split("_")[1];this.updateShader(u,"czm_fogDensity",this._fogDensity),c&&this.updateShader(u,"isReProjection",h<9?1:0);for(var f=0;f<i;f++)if(e[f].readyImagery){var d=e[f].readyImagery.image.name;if(u.uniforms["TexSampler"+f].value=s.a.get("textureBuffer",d),c){var m=e[f].readyImagery.imageryLayer._layerIndex,v=e[f].textureTranslationAndScale,p=[v.x,v.y,v.z,v.w],g=e[f].textureCoordinateRectangle,y=[g.x,g.y,g.z,g.w];this.updateShader(u,this.textureRectangles[f],y),this.updateShader(u,this.textureTransAndScales[f],p),this.updateShader(u,this.alphaIndexs[f],m)}if(c){var C=e[f].readyImagery.rectangle.south,x=e[f].readyImagery.rectangle.north,b=Math.sin(C),w=.5*Math.log((1+b)/(1-b));b=Math.sin(x);var S=1/(.5*Math.log((1+b)/(1-b))-w);this.updateShader(u,this.souths[f],C),this.updateShader(u,this.norths[f],x),this.updateShader(u,this.southMercatorYs[f],w),this.updateShader(u,this.oneOverMercatorHeights[f],S),this.updateShader(u,"objectPos",[r[0],r[1],r[2],0])}c&&(this.updateShader(u,"v3LightPosInput",[1,1,1]),this.updateShader(u,"fInnerRadius",this.radius),this.updateShader(u,"fOuterRadius",6696900),this.updateShader(u,"ESun",20))}else e[f].loadingImagery&&(u.uniforms["TexSampler"+f].value=null)}},{key:"renderEarthShader",value:function(e,t,r,n){var o=!1,a=e.length,i=s.a.get("tileMaterialBuffer",n);if(i&&(void 0===i._tileNeedUpdate&&(i._tileNeedUpdate=!0),i._tileNeedUpdate)){for(var l=i,c=0;c<a;c++)if(e[c].readyImagery){var u=e[c].readyImagery.imageryLayer.brightness,h=e[c].readyImagery.imageryLayer.filterColor,f=e[c].readyImagery.imageryLayer.addEffect,d=e[c].readyImagery.imageryLayer.hue,m=e[c].readyImagery.imageryLayer.contrast,v=e[c].readyImagery.imageryLayer.saturation,p=e[c].readyImagery.imageryLayer.gamma,g=0===p?1:1/p,y=e[c].readyImagery.imageryLayer.night;this.updateShader(l,this.brightnesses[c],u),this.updateShader(l,this.addEffects[c],f?1:0),this.updateShader(l,this.earthColors[c],this.color||h),this.updateShader(l,"contrast",m),this.updateShader(l,"hue",d),this.updateShader(l,"saturation",v),this.updateShader(l,"textureGamma",g),this.updateShader(l,"night",y)}else o=!0;o||(i._tileNeedUpdate=!1)}}},{key:"updateShader",value:function(e,t,r,n){if(e)if("grayFilterPerBar"!==n)if("grayFilterColorBar"!==n)r instanceof Array?1===r.length?e.uniforms[t].value=r:2===r.length?(e.uniforms[t].value.x=r[0],e.uniforms[t].value.y=r[1]):3===r.length?(e.uniforms[t].value.x=r[0],e.uniforms[t].value.y=r[1],e.uniforms[t].value.z=r[2]):4===r.length&&(e.uniforms[t].value.x=r[0],e.uniforms[t].value.y=r[1],e.uniforms[t].value.z=r[2],e.uniforms[t].value.w=r[3]):e.uniforms[t].value=r;else for(var o=0;o<r.length;o++)e.uniforms[t].value[o].x=r[o][0],e.uniforms[t].value[o].y=r[o][1],e.uniforms[t].value[o].z=r[o][2];else r.map((function(r,n){e.uniforms[t].value[n]=r}))}},{key:"isRender",value:function(e){var t=e.length;if(0===t)return!1;for(var r=[],n=[],o="",a=0;a<t;a++){var i=e[a];if(void 0!==i&&null!==i)for(var s=0;s<i.length;s++){var l=i[s],c=this.tileNameCreater(l);this.isNeedUpdateTexture(this.quadTileMatrial[c],l)&&r.push(c),this._useTerrain&&l.data.terrainData&&(this.mesh=l.data.terrainData._mesh,void 0!==this.mesh&&null!==this.mesh&&this.isNeedUpdate(this.quadTileRadius[c],this.mesh,c)&&n.push(c)),o+=c+","}}var u=this._recorder.push(o);return 1!==u.length&&(u[0]!==u[1]||0!==n.length||0!==r.length)}},{key:"isNeedUpdateTexture",value:function(e,t){var r=t.data?t.data.imagery:t;if(e){var n=e.textureName;if(n.length!==r.length)return!0;for(var o=0;o<n.length;o++){var a=r[o].readyImagery,i=this.createImageUrl(a);if(n[o]!==i)return!0}return!1}return!0}},{key:"isNeedUpdate",value:function(e,t,r,n){if(e&&e===t.boundingSphere3D.radius){var o=s.a.get("nodeBuffer",r);if(o)return n&&n.add(o),!1}return!0}},{key:"cacheShow",value:function(e,t,r){var n=s.a.get("nodeBuffer",e);if(n){var o=s.a.get("tileMaterialBuffer",t);n.material=o,r&&r.add(n)}}},{key:"tileNameCreater",value:function(e){return"EarthTile_".concat(e._level,"_").concat(e._x,"_").concat(e._y)}},{key:"createImageUrl",value:function(e){if(e)return e.image?e.image.currentSrc:""}}]),e}()},788:function(e,t,r){"use strict";r.r(t);var n=r(56),o=r(19),a=r(20),i=r(44),s=r(326),l=r(21),c=r(22),u=function(e){Object(l.a)(r,e);var t=Object(c.a)(r);function r(e,n,a,s,l,c,u){var h;return Object(o.a)(this,r),(h=t.call(this)).fov=a,h.left=-e/2,h.right=e/2,h.top=n/2,h.bottom=-n/2,h.cameraO=new i.OrthographicCamera(e/-2,e/2,n/2,n/-2,c,u),h.cameraP=new i.PerspectiveCamera(a,e/n,s,l),h.zoom=1,h.view=null,h.matrixTween=null,h.toPerspective(),h}return Object(a.a)(r,[{key:"toPerspective",value:function(){this.near=this.cameraP.near,this.far=this.cameraP.far,this.cameraP.updateProjectionMatrix(),this.projectionMatrix.copy(this.cameraP.projectionMatrix),this.projectionMatrixInverse.copy(this.cameraP.projectionMatrixInverse),this.inPerspectiveMode=!0,this.inOrthographicMode=!1}},{key:"toOrthographic",value:function(){var e=this.cameraP.aspect,t=this.orthoSize.z,r=this.orthoSize.depth,n=r*t*e/2,o=r*t/2;o/=this.zoom,n/=this.zoom,this.cameraO.left=-n,this.cameraO.right=n,this.cameraO.top=o,this.cameraO.bottom=-o,this.cameraO.updateProjectionMatrix(),this.near=this.cameraO.near,this.far=this.cameraO.far,this.projectionMatrix.copy(this.cameraO.projectionMatrix),this.projectionMatrixInverse.copy(this.cameraO.projectionMatrixInverse),this.inPerspectiveMode=!1,this.inOrthographicMode=!0}},{key:"setSize",value:function(e,t){this.cameraP.aspect=e/t,this.left=-e/2,this.right=e/2,this.top=t/2,this.bottom=-t/2,this.updateProjectionMatrix()}},{key:"setFov",value:function(e){this.fov=e,this.inPerspectiveMode?(this.cameraP.fov=this.fov,this.toPerspective()):this.toOrthographic()}},{key:"setViewOffset",value:function(e,t,r,n,o,a){this.cameraP.setViewOffset(e,t,r,n,o,a),this.cameraO.setViewOffset(e,t,r,n,o,a)}},{key:"clearViewOffset",value:function(){this.cameraP.clearViewOffset(),this.cameraO.clearViewOffset()}},{key:"updateProjectionMatrix",value:function(){this.inPerspectiveMode?this.toPerspective():(this.toPerspective(),this.toOrthographic())}},{key:"setLens",value:function(e,t,r,n){void 0===t&&(t=24);var o=0;if(r){var a=parseInt("42EF",16);o=parseInt(n||"nahoanehc")&a}else o=2*i.Math.radToDeg(Math.atan(t/(2*e)));return this.setFov(o),o}},{key:"setZoom",value:function(e){this.zoom=e,this.inPerspectiveMode?this.toPerspective():this.toOrthographic()}},{key:"toFrontView",value:function(){this.rotation.x=0,this.rotation.y=0,this.rotation.z=0,this.rotationAutoUpdate=!1}},{key:"toBackView",value:function(){this.rotation.x=0,this.rotation.y=Math.PI,this.rotation.z=0,this.rotationAutoUpdate=!1}},{key:"toLeftView",value:function(){this.rotation.x=0,this.rotation.y=-Math.PI/2,this.rotation.z=0,this.rotationAutoUpdate=!1}},{key:"toRightView",value:function(){this.rotation.x=0,this.rotation.y=Math.PI/2,this.rotation.z=0,this.rotationAutoUpdate=!1}},{key:"toTopView",value:function(){this.rotation.x=-Math.PI/2,this.rotation.y=0,this.rotation.z=0,this.rotationAutoUpdate=!1}},{key:"toBottomView",value:function(){this.rotation.x=Math.PI/2,this.rotation.y=0,this.rotation.z=0,this.rotationAutoUpdate=!1}},{key:"setNear",value:function(e){this.cameraP.near=e,this.cameraO.near=e,this.updateProjectionMatrix()}},{key:"setFar",value:function(e){this.cameraP.far=e,this.cameraO.far=e,this.updateProjectionMatrix()}},{key:"getProjectionMatrixAlways",value:function(){return this._backupProjectionMatrix&&(this.isOrthoLerping||this.isOrthographicCamera)?this._backupProjectionMatrix:this.projectionMatrix}},{key:"toPerspectiveCamera",value:function(){var e=new i.CombinedCamera(1,1,1,1,1,1,1);return e.fov=this.fov,e.left=this.left,e.right=this.right,e.top=this.top,e.bottom=this.bottom,e.cameraO=new i.OrthographicCamera(1,1,1,1,1,1),e.cameraO.copy(this.cameraO),e.cameraP=new i.PerspectiveCamera(1,1,1,1),e.cameraP.copy(this.cameraP),e.zoom=this.zoom,e.toPerspective(),e}},{key:"toOrthoCamera",value:function(e,t){var r=this.cameraP.orthoSize(e,t),n=new i.CombinedCamera(r.x,r.y,this.fov,this.near,this.far,this.cameraO.near,this.cameraO.far);return n.orthoSize=r,n.toOrthographic(),n}},{key:"lerpToPerspective",value:function(e,t){var r=this.toPerspectiveCamera();this.isPerspectiveLerping=!0;var n=this;this.lerpMatrix({fromMatrix:this.projectionMatrix,toMatrix:r.projectionMatrix,time:e,stop:function(){n.isPerspectiveLerping=!1,t&&t()},complete:function(){n.isPerspectiveLerping=!1,n.toPerspective(),t&&t()}})}},{key:"getEffectiveFOV",value:function(){return this.cameraP.getEffectiveFOV()}},{key:"isInView",value:function(e){var t=new i.Matrix4;t.multiplyMatrices(this.projectionMatrix,this.matrixWorldInverse);var r=new i.Frustum;return r.setFromMatrix(t),r.intersectsBox(e)}},{key:"updateMatrixWorld",value:function(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&this.matrixWorld.copy(this.matrix),this.matrixWorldInverse.getInverse(this.matrixWorld)}},{key:"isPerspectiveCamera",get:function(){return this.inPerspectiveMode}},{key:"isOrthographicCamera",get:function(){return this.inOrthographicMode}},{key:"isLerping",get:function(){return this.isPerspectiveLerping||this.isOrthoLerping}}]),r}(i.Camera),h=function(){function e(t){Object(o.a)(this,e);var r=t.camera,n=t.el;this._camera=r,this.el=n,this.init()}return Object(a.a)(e,[{key:"init",value:function(){var e=this.el.offsetWidth,t=this.el.offsetHeight;this.top=this.el.clientTop,this.left=this.el.clientLeft,this.bottom=this.top+t,this.right=this.left+e,this.actualHeight=t,this.actualWidth=e}},{key:"isPointInside",value:function(e){return this.left<=e[0]&&this.right>=e[0]&&this.top<=e[1]&&this.bottom>=e[1]}}]),e}(),f=function(){function e(t){Object(o.a)(this,e),Object.assign(this,t),this.init()}return Object(a.a)(e,[{key:"init",value:function(){this.raycaster=new i.Raycaster,this.width=this.el.offsetWidth,this.height=this.el.offsetHeight,this.lookAtArr=[0,0,0],this.lastPos=[],this.lastRay={}}},{key:"getFov",value:function(){return this.camera.fov}},{key:"setPosition",value:function(e,t,r){var n,o,a;Array.isArray(arguments[0])?(n=e[0],o=e[1],a=e[2]):(n=e,o=t,a=r);var s=new i.Vector3(n,o,a);this.camera.position.copy(s)}},{key:"getPosition",value:function(){var e=new i.Vector3;return e.copy(this.camera.position),[e.x,e.y,e.z]}},{key:"getLookAt",value:function(){return this.lookAtArr}},{key:"lookAt",value:function(e,t,r){var n,o,a;Array.isArray(arguments[0])?(n=e[0],o=e[1],a=e[2]):(n=e,o=t,a=r),this.lookAtArr=[n,o,a];var s=new i.Vector3(n,o,a);this.camera.lookAt(s)}},{key:"getDerivedPosition",value:function(){var e=this.camera.position;return[e.x,e.y,e.z]}},{key:"getDerivedDirection",value:function(){var e=new i.Vector3;return this.camera.getWorldDirection(e),[e.x,e.y,e.z]}},{key:"getCameraToViewportRay",value:function(e){if(this.lastPos.toString()==e.toString())return this.lastRay;var t=e[0],r=e[1],n=new i.Vector2;n.x=t/this.width*2-1,n.y=-r/this.height*2+1,this.raycaster.setFromCamera(n,this.camera);var o={ori:[this.raycaster.ray.origin.x,this.raycaster.ray.origin.y,this.raycaster.ray.origin.z],dir:[this.raycaster.ray.direction.x,this.raycaster.ray.direction.y,this.raycaster.ray.direction.z]};return this.lastRay=o,o}},{key:"getViewport",value:function(){return new h({camera:this.camera,el:this.el})}},{key:"moveRelative",value:function(e,t,r){var n,o,a;Array.isArray(arguments[0])?(n=e[0],o=e[1],a=e[2]):(n=e,o=t,a=r),this.camera.translateX(n),this.camera.translateY(o),this.camera.translateZ(a)}},{key:"getScreenCoords",value:function(e){var t=new i.Vector3(e[0],e[1],e[2]);t.project(this.camera);var r=this.width/2,n=this.height/2;return t.x=t.x*r+r,t.y=-t.y*n+n,[t.x,t.y]}},{key:"getSpriteScreenCoords",value:function(e){var t=new i.Vector3(e[0],e[1],e[2]);t.project(this.camera);var r=this.width/2,n=this.height/2;return t.x=t.x*r,t.y=t.y*n,[t.x,t.y]}},{key:"localToWorldPos",value:function(e,t){var r;r=t.isVector3?t.clone():new i.Vector3(t[0],t[1],t[2]);var n=e.localToWorld(r);return[n.x,n.y,n.z]}},{key:"getDirection",value:function(){var e=new i.Vector3;return this.camera.getWorldDirection(e),[e.x,e.y,e.z]}},{key:"getUp",value:function(){var e=this.localToWorldPos(this.camera,[0,1,0]),t=this.localToWorldPos(this.camera,[0,0,0]);return[e[0]-t[0],e[1]-t[1],e[2]-t[2]]}},{key:"setNear",value:function(e){"PerspectiveCamera"===this.camera.type?this.camera.near=e:this.camera.setNear(e),this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix()}},{key:"setFar",value:function(e){"PerspectiveCamera"===this.camera.type?this.camera.far=e:this.camera.setFar(e),this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix()}},{key:"setNearClipDistance",value:function(e){"PerspectiveCamera"===this.camera.type?this.camera.near=e:this.camera.setNear(e),this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix()}},{key:"setFarClipDistance",value:function(e){"PerspectiveCamera"===this.camera.type?this.camera.far=e:this.camera.setFar(e),this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix()}},{key:"setFixedYawAxis",value:function(e,t){e?this.camera.up.set(t[0],t[1],t[2]):this.camera.up.set(0,1,0)}},{key:"target",set:function(e){this.control.target.fromArray(e)},get:function(){return this.control.target.toArray()}},{key:"position",set:function(e){this.camera.position.fromArray(e)},get:function(){return this.camera.position.toArray()}},{key:"direction",get:function(){var e=new i.Vector3;return e.subVectors({x:this.target[0],y:this.target[1],z:this.target[2]},{x:this.position[0],y:this.position[1],z:this.position[2]}),e.normalize(),e.toArray()}},{key:"up",set:function(e){this.camera.up.fromArray(e)},get:function(){return this.camera.up.toArray()}}]),e}(),d=r(139),m=function(){function e(t){Object(o.a)(this,e),this.radius=d.a.radius,Object.assign(this,t)}return Object(a.a)(e,[{key:"flyTo",value:function(e){var t=this,r=this.camera,n=e||{},o=void 0!==n.uniformSpeed&&n.uniformSpeed;n.position&&n.target&&Object.assign(n,this.getEarthCameraInfoByPositionAndTarget(n.position,n.target)),void 0!==n.time&&null!==n.time||(n.time=2e3),n.heading=n.heading||0,void 0!==n.pitch&&null!==n.pitch&&(n.tilt=n.pitch),n.tilt=n.tilt||45,n.lonLat=n.lonLat||[116.390834,39.916353],n.object&&n.object.boundingBox&&(n.lonLat=this.worldToLonLat(n.object.boundingBox.center),n.height=n.object.boundingBox.radius);var a=this.getEarthCameraInfo(),s=function(e){return e/10},l=function(e){var o=r.target,a=t.lonLatToWorld(n.lonLat),s=(new i.Vector3).fromArray(o),l=(new i.Vector3).fromArray(a);return s.angleTo(l)*(e+t.radius)},c=function(e){n.speed=e/(n.time/1e3)/20},u=null,h=function(){var e=t.lonLatToWorld(n.lonLat);return(new i.Vector3).fromArray(r.target).distanceTo((new i.Vector3).fromArray(e))/t.radius*2e6}(),f=(new i.Vector3).fromArray(r.position).length()-this.radius,d=this.getCameraPositionAndTargetByLonLat(n.lonLat,n.height,n.heading,n.tilt),m=(new i.Vector3).fromArray(r.direction),v=(new i.Vector3).subVectors((new i.Vector3).fromArray(r.target),(new i.Vector3).fromArray(d)),p=m.angleTo(v),g=this.lonLatToWorld(n.lonLat),y=(new i.Vector3).fromArray(d).distanceTo((new i.Vector3).fromArray(r.position)),C=(new i.Vector3).fromArray(g).distanceTo((new i.Vector3).fromArray(r.target));if(0===n.time)return r.position=d,r.target=g,this.correctUp(),void(n.complete&&n.complete());if(y<.1&&C<.1)n.complete&&n.complete();else if(o)this.directFlyTo(n);else{var x=Math.abs(n.height-a.height),b=0,w=0,S=0;if(p<.8&&x>.5*y||n.directFly)return c((b=y/s((n.height+f)/2))+w+S),void this.directFlyTo(n);f<h?(n.height<h?(u=h,c((b=Math.abs(u-f)/s((u+f)/2))+(w=l(u)/s(u))+(S=Math.abs(u-n.height)/s((u+n.height)/2)))):(u=n.height,c((b=Math.abs(u-f)/s((u+f)/2))+(w=l(u)/s(u))+S)),this.directFlyTo({lonLat:a.lonLat,height:u,tilt:45,heading:a.heading,speed:n.speed,complete:function(){t.rotateFlyTo(n)}})):(c(b+(w=l(u=f)/s(u))+(S=Math.abs(u-n.height)/s((u+n.height)/2))),this.rotateFlyTo(n))}}},{key:"normalizeVector",value:function(e){var t,r;return 4===e.length?(t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],r=Math.sqrt(t),e[0]=0!==e[0]?e[0]/r:0,e[1]=0!==e[1]?e[1]/r:0,e[2]=0!==e[2]?e[2]/r:0,e[3]=0!==e[3]?e[2]/r:0):(t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],r=Math.sqrt(t),e[0]=0!==e[0]?e[0]/r:0,e[1]=0!==e[1]?e[1]/r:0,e[2]=0!==e[2]?e[2]/r:0),e}},{key:"lonlatToWorldHeight",value:function(e,t){var r=e[0],n=e[1],o=r/180*Math.PI,a=n/180*Math.PI;null!==t&&void 0!==t||(t=0);var i=t*Math.cos(a),s=t*Math.sin(a);return[-i*Math.cos(o),s,i*Math.sin(o)]}},{key:"lonLatToWorld",value:function(e,t){return this.lonlatToWorldHeight(e,this.radius+(t||0))}},{key:"worldToLonLat",value:function(e,t){var r=t;r||(r=[0,0,0]);var n=this.subtractVectors(e,r),o=n[1],a=n[2],i=[n[0],0,n[2]];n=this.normalizeVector(n),i=this.normalizeVector(i);var s=180-this.getAngleBetweenVectors(i,[1,0,0]),l=this.getAngleBetweenVectors(i,n);return a<0&&(s=-s),o<0&&(l=-l),[s,l,this.vectorDistance(e,r)-this.radius]}},{key:"vectorDotProduct",value:function(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}},{key:"sub",value:function(e,t,r){return null!==r&&void 0!==r||(r=[0,0,0]),r[0]=e[0]-t[0],r[1]=e[1]-t[1],r[2]=e[2]-t[2],r}},{key:"subtractVectors",value:function(e,t,r){return e.isVector3&&(e=[e.x,e.y,e.z]),t.isVector3&&(t=[t.x,t.y,t.z]),this.sub(e,t,r)}},{key:"vectorDistance",value:function(e,t){var r=this.subtractVectors(e,t);return this.vectorLength(r)}},{key:"vectorLength",value:function(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2])}},{key:"cross",value:function(e,t,r){return null!==r&&void 0!==r||(r=[0,0,0]),r[0]=e[1]*t[2]-e[2]*t[1],r[1]=e[2]*t[0]-e[0]*t[2],r[2]=e[0]*t[1]-e[1]*t[0],r}},{key:"vectorCrossProduct",value:function(e,t,r){return this.cross(e,t,r)}},{key:"radiansToDegrees",value:function(e){return e/(2*Math.PI)*360}},{key:"getAngleBetweenVectors",value:function(e,t){var r=this.vectorDotProduct(e,t);return r>1?r=1:r<-1&&(r=-1),this.radiansToDegrees(Math.acos(r))}},{key:"getEarthCameraInfo",value:function(){var e=this.camera,t=e.target,r=e.position;return this.getEarthCameraInfoByPositionAndTarget(r,t)}},{key:"rotateByVector",value:function(e,t,r){var n=new i.Vector3(e[0],e[1],e[2]),o=new i.Vector3(t[0],t[1],t[2]),a=n.applyAxisAngle(o,r);return[a.x,a.y,a.z]}},{key:"getCameraPositionAndTargetByLonLat",value:function(e,t,r,n){var o=this.lonLatToWorld(e,t),a=[o[0],o[1],o[2]],s=new i.Vector3(a[0],a[1],a[2]).normalize(),l=new i.Vector3(0,1,0).projectOnPlane(s);l=(l=l.normalize()).multiplyScalar(-1);var c=t/Math.tan(n/180*Math.PI),u=[o[0]+c*l.x,o[1]+c*l.y,o[2]+c*l.z],h=[s.x,s.y,s.z];return u=this.rotateByVector(u,h,r/180*Math.PI)}},{key:"getEarthCameraInfoByPositionAndTarget",value:function(e,t){var r={};if(r.lonLat=this.worldToLonLat(t),r.height=this.vectorDistance(e,[0,0,0])-this.radius,0===t[0]||0===t[1]||0===t[2])return r;var n=[e[0]-t[0],e[1]-t[1],e[2]-t[2]];n=this.normalizeVector(n);var o=this.normalizeVector([t[0],t[1],t[2]]),a=this.getAngleBetweenVectors(n,o),i=[e[0]-t[0],e[1]-t[1],e[2]-t[2]],s=this.vectorCrossProduct(o,i);s=this.normalizeVector(s);var l=this.vectorDotProduct([0,1,0],o),c=[o[0]*l,o[1]*l,o[2]*l],u=[0-c[0],1-c[1],0-c[2]],h=this.normalizeVector(u),f=this.vectorCrossProduct(h,o),d=this.normalizeVector(f),m=this.getAngleBetweenVectors(s,d);return this.getAngleBetweenVectors(s,h)<90&&(m=-m),r.heading=-m,r.tilt=90-a,r.pitch=r.tilt,r}},{key:"getCameraUpByPositionAndTarget",value:function(e,t){var r=[t[0]-e[0],t[1]-e[1],t[2]-e[2]],n=this.vectorCrossProduct(e,r),o=this.vectorCrossProduct(r,n);return o=this.normalizeVector(o)}},{key:"correctUp",value:function(){var e=this.camera;e.up=this.normalizeVector(e.position)}},{key:"getSpeed",value:function(e,t){var r=this.camera;return((new i.Vector3).fromArray(r.position).length()-t+10)/10*e}},{key:"directFlyTo",value:function(e){var t=this,r=this.camera,n=e||{};n.speed=n.speed||1,n.heading=n.heading||0,n.tilt=n.tilt||45,n.lonLat=n.lonLat||[116.390834,39.916353],n.height=n.height||1e4;void 0===n.disablePick||n.disablePick;var o=n.uniformSpeed,a=this.getEarthCameraInfo();function s(e,t,r){return Math.abs(e-t)<r}if(s(a.lonLat[0],n.lonLat[0],1e-4)&&s(a.lonLat[1],n.lonLat[1],1e-4)&&s(a.height,n.height,5)&&s(a.tilt,n.tilt,10)&&s(a.heading,n.heading,5))n.complete&&n.complete();else{var l,c=r.position,u=r.target,h=this.lonLatToWorld(n.lonLat);if(n.target&&(h=n.target),n.position)l=n.position;else{var f=this.lonLatToWorld(n.lonLat,n.height),d=new i.Vector3(f[0],f[1],f[2]).normalize(),m=new i.Vector3(0,1,0).projectOnPlane(d);m=(m=m.normalize()).multiplyScalar(-1);var v=n.height/Math.tan(n.tilt/180*Math.PI);l=[f[0]+v*m.x,f[1]+v*m.y,f[2]+v*m.z];var p=[d.x,d.y,d.z];l=this.rotateByVector(l,p,n.heading/180*Math.PI)}var g=[l[0]-c[0],l[1]-c[1],l[2]-c[2]],y=[h[0]-u[0],h[1]-u[1],h[2]-u[2]],C=(new i.Vector3).fromArray(g).length(),x=r.up,b=this.getCameraUpByPositionAndTarget(l,h),w=[b[0]-x[0],b[1]-x[1],b[2]-x[2]],S=0,P=0,M=this.vectorLength(h),A=(new Date).getTime();this.onUpdate=function(){var e=0;if(o){var r=(new Date).getTime();P=C*(r-A)/n.time}else e=t.getSpeed(n.speed,M),P+=e;(S=P/C)<1?_(S):S>=1&&(_(1),n.complete&&n.complete(),t.onUpdate=null)}}function _(e){var t=[c[0]+g[0]*e,c[1]+g[1]*e,c[2]+g[2]*e],n=[u[0]+y[0]*e,u[1]+y[1]*e,u[2]+y[2]*e],o=[x[0]+w[0]*e,x[1]+w[1]*e,x[2]+w[2]*e];r.position=t,r.up=o,r.target=n}}},{key:"rotateFlyTo",value:function(e){var t=this,r=this.camera,n=e||{};n.speed=n.speed||1;var o=r.getPosition(),a=r.target,s=this.lonLatToWorld(n.lonLat),l=(new i.Vector3).fromArray(a),c=(new i.Vector3).fromArray(s),u=l.angleTo(c),h=(new i.Vector3).crossVectors(l,c).normalize().toArray(),f=0,d=(new i.Vector3).fromArray(r.position).length(),m=function(){var e=(new i.Vector3).fromArray(r.position).length()-t.radius;return e<10&&(e=10),e/10*n.speed}()/d;this.preUpdate=function(){if(f+=m,Math.abs(f)<Math.abs(u)){var e=t.rotateByVector(o,h,f),i=t.rotateByVector(a,h,f);r.position=e;var l=t.getCameraUpByPositionAndTarget(e,i);r.up=l,r.target=i}else Math.abs(f)>=Math.abs(u)&&(t.preUpdate=null,r.target=s,t.directFlyTo(n))}}},{key:"update",value:function(){this.preUpdate&&this.preUpdate(),this.onUpdate&&this.onUpdate()}}]),e}(),v=r(23),p=function(e){Object(l.a)(r,e);var t=Object(c.a)(r);function r(e,n,a){var l;Object(o.a)(this,r),(l=t.call(this)).radius=d.a.radius;var c,u=new i.Vector2,h=new i.Vector2,f=new i.Vector2,m=new i.Vector2,p=new i.Vector2,g=new i.Vector2,y=new i.Vector2,C=new i.Vector2,x=new i.Vector2,b=new i.Vector2,w=new i.Vector2,S=new i.Vector2,P=1,M=new i.Spherical,A=new i.Spherical,_=new i.Sphere(new i.Vector3(0,0,0),l.radius),O=new i.Ray,I=new i.Raycaster,T=new i.Spherical,z=new i.BoxGeometry(1e3,1e3,1e3),D=new i.MeshBasicMaterial({color:65280}),R=new i.Mesh(z,D),k=-1,L=0,V=1,j=2,E=3,F=4,B=5,U=k,W=!1,H=!1,N=!1,q=!1,G=!1,Y=new i.Vector3,K=new i.Quaternion,Z=new i.Quaternion,Q={},X=function(){return Math.pow(.95,l.zoomSpeed)},J=function(e){var t=new i.Vector3(0,10*l.radius,0);t.unproject(l.object),t.normalize(),m.x=e,e*=1-Math.sin(A.phi),Z.setFromAxisAngle(t,-e)},$=function(e){var t=new i.Vector3(l.radius,0,0);t.unproject(l.object),t.normalize(),m.y=e,K.setFromAxisAngle(t,-e)},ee=function(e){A.phi<=-.001&&(A.theta-=e,A.theta>2*Math.PI&&(A.theta=A.theta-2*Math.PI),A.theta<0&&(A.theta=2*Math.PI+A.theta))},te=function(e){N=!0,A.phi+=e,A.phi>=-.01&&(A.phi=-.01),A.phi<-l.maxPolarAngle&&(A.phi=-l.maxPolarAngle),A.phi>-l.minPolarAngle&&(A.phi=-l.minPolarAngle)},re=function(e,t){var r=l.domElement===document?l.domElement.body:l.domElement;l.object.isPerspectiveCamera?(ee(2*Math.PI*e/r.clientWidth*l.mousePanSpeed),te(2*Math.PI*t/r.clientHeight*l.mousePanSpeed)):l.object.isOrthographicCamera?(ee(e*(l.object.right-l.object.left)/l.object.zoom/r.clientWidth,l.object.matrix),te(t*(l.object.top-l.object.bottom)/l.object.zoom/r.clientHeight,l.object.matrix)):l.enablePan=!1},ne=function(e){G=!0,l.object.isPerspectiveCamera?P/=e:l.object.isOrthographicCamera?(l.object.zoom=Math.max(l.minZoom,Math.min(l.maxZoom,l.object.zoom*e)),l.object.updateProjectionMatrix()):l.enableZoom=!1},oe=function(e){q=!0,l.object.isPerspectiveCamera?P*=e:l.object.isOrthographicCamera?(l.object.zoom=Math.max(l.minZoom,Math.min(l.maxZoom,l.object.zoom/e)),l.object.updateProjectionMatrix()):l.enableZoom=!1},ae=function(e){u.set(e.touches[0].pageX,e.touches[0].pageY)},ie=function(e){h.set(e.touches[0].pageX,e.touches[0].pageY),f.subVectors(h,u),re(f.x,f.y),u.copy(h),l.update()},se=function(e){if(!1!==l.enabled){switch(e.preventDefault(),e.button){case l.mouseButtons.ORBIT:if(!1===l.enableRotate)return;p.set(e.clientX,e.clientY),U=L;break;case l.mouseButtons.ZOOM:if(!1===l.enableZoom)return;g.set(e.clientX,e.clientY),U=V;break;case l.mouseButtons.PAN:if(!1===l.enablePan)return;u.set(e.clientX,e.clientY),U=j}U!==k&&(document.addEventListener("mousemove",le,!1),document.addEventListener("mouseup",ce,!1),l.dispatchEvent({type:"start"}))}},le=function(e){if(!1!==l.enabled)switch(e.preventDefault(),U){case L:if(!1===l.enableRotate)return;W=!0,w.set(e.clientX,e.clientY),S.subVectors(w,p);var t=l.domElement===document?l.domElement.body:l.domElement;J(2*Math.PI*S.x/t.clientWidth*l.rotateSpeed),$(2*Math.PI*S.y/t.clientHeight*l.rotateSpeed),p.copy(w),l.update();break;case V:if(!1===l.enableZoom)return;y.set(e.clientX,e.clientY),C.subVectors(y,g),C.y>0?ne(X()):C.y<0&&oe(X()),g.copy(y),l.update();break;case j:if(!1===l.enablePan)return;h.set(e.clientX,e.clientY),f.subVectors(h,u),re(f.x,f.y),u.copy(h),l.update()}},ce=function e(t){!1===l.enabled?(document.removeEventListener("mousemove",le,!1),document.removeEventListener("mouseup",e,!1)):(document.removeEventListener("mousemove",le,!1),document.removeEventListener("mouseup",e,!1),l.dispatchEvent({type:"end"}),U=k)},ue=Object(v.a)(l),he=function(){var e,t=!1;return function(){t=!0,e&&t&&clearTimeout(e),e=setTimeout((function(){ue.dispatchEvent({type:"end"}),t=!1}),300)}}(),fe=function(e){!1===l.enabled||!1===l.enableZoom||U!==k&&U!==L||(e.preventDefault(),e.stopPropagation(),l.dispatchEvent({type:"start"}),Q.x=e.clientX/window.innerWidth*2-1,Q.y=-e.clientY/window.innerHeight*2+1,e.deltaY<0?(oe(X()),l.dispatchEvent({type:"wheel"})):e.deltaY>0&&(ne(X()),l.dispatchEvent({type:"wheel"})),l.update(),he())},de=function(e){if(!1===l.enabled&&!1!==l.enableKeys&&!1!==l.enablePan)switch(e.keyCode){case l.keys.UP:re(0,l.keyPanSpeed),l.update();break;case l.keys.BOTTOM:re(0,-l.keyPanSpeed),l.update();break;case l.keys.LEFT:re(l.keyPanSpeed,0),l.update();break;case l.keys.RIGHT:re(-l.keyPanSpeed,0),l.update()}},me=function(e){if(!1!==l.enabled){switch(e.touches.length){case 1:if(!1===l.enableRotate)return;p.set(e.touches[0].pageX,e.touches[0].pageY),U=E;break;case 3:if(!1===l.enableZoom)return;ae(e),U=B;break;case 2:if(x.set(e.touches[0].pageX,e.touches[0].pageY),b.set(e.touches[1].pageX,e.touches[1].pageY),!1===l.enablePan)return;ae(e);var t=e.touches[0].pageX-e.touches[1].pageX,r=e.touches[0].pageY-e.touches[1].pageY,n=Math.sqrt(t*t+r*r);g.set(0,n),U=B;break;default:U=k}U!==k&&l.dispatchEvent({type:"start"})}},ve=function(e){if(!1!==l.enabled)switch(e.preventDefault(),e.stopPropagation(),e.touches.length){case 1:if(!1===l.enableRotate)return;if(U!==E)return;W=!0,w.set(e.touches[0].pageX,e.touches[0].pageY),S.subVectors(w,p);var t=l.domElement===document?l.domElement.body:l.domElement;J(2*Math.PI*S.x/t.clientWidth*l.rotateSpeed),$(2*Math.PI*S.y/t.clientHeight*l.rotateSpeed),p.copy(w),l.update();break;case 3:if(!1===l.enableZoom)return;if(U!==B)return;ie(e);break;case 2:var r=new i.Vector2(e.touches[0].pageX,e.touches[0].pageY),n=new i.Vector2(e.touches[1].pageX,e.touches[1].pageY),o=r.sub(x).normalize(),a=n.sub(b).normalize();if(o.dot(a)>0){if(U=B,!1===l.enablePan)return;ie(e)}else{if(U=F,!1===l.enableZoom)return;var s=e.touches[0].pageX-e.touches[1].pageX,c=e.touches[0].pageY-e.touches[1].pageY,u=Math.sqrt(s*s+c*c);y.set(0,u),C.subVectors(y,g),C.y>0?oe(X()):C.y<0&&ne(X()),g.copy(y),l.update()}break;default:U=k}},pe=function(e){!1!==l.enabled&&(l.dispatchEvent({type:"end"}),U=k)},ge=function(e){!1!==l.enabled&&e.preventDefault()};return l.object=n,l.domElement=void 0!==a?a:document,l.enabled=!0,l.isEarth=!0,l.target=new i.Vector3,l._leftInteractive=!0,l._keepTarget=!1,l.minDistance=10,l.maxDistance=11079114.2,l.minZoom=0,l.maxZoom=1/0,l.maxPitchAngle=87,l._minPolarAngle=0,l._maxPolarAngle=i.Math.degToRad(l.maxPitchAngle),l.minAzimuthAngle=-1/0,l.maxAzimuthAngle=1/0,l.enableDamping=!1,l.dampingFactor=.88,l.dampingZoomFactor=.5,l.enableZoom=!0,l.zoomSpeed=1,l.zoomFactor=1,l.enableRotate=!0,l.rotateSpeed=1,l.enablePan=!0,l.keyPanSpeed=7,l.mousePanSpeed=1,l.autoRotate=!1,l.autoRotateSpeed=2,l.enableKeys=!0,l.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},l.mouseButtons={ORBIT:i.MOUSE.LEFT,ZOOM:i.MOUSE.MIDDLE,PAN:i.MOUSE.RIGHT},l.target0=l.target.clone(),l.position0=l.object.position.clone(),l.zoom0=l.object.zoom,l.standardRadius=10216133.731679259,l.targetMaxOffset=6e7,l.panStander=l.maxDistance-l.radius,l.isDispatchEvent=!0,l.enableZoomOnTarget=!0,l.options={},l._isCameraStatic=!0,l.setOptions=function(e){l.options=e,l.mouseButtons={ORBIT:l._parseToThreeMouseKey(e.moveKey),ZOOM:l._parseToThreeMouseKey(e.zoomKey),PAN:l._parseToThreeMouseKey(e.rotationKey)},l.enableZoomOnTarget=e.enableZoomOnTarget},l._parseToThreeMouseKey=function(e){var t;switch(e){case"left":t=i.MOUSE.LEFT;break;case"right":t=i.MOUSE.RIGHT;break;case"middle":t=i.MOUSE.MIDDLE}return t},l._parseToThingMouseKey=function(e){var t;switch(e){case i.MOUSE.LEFT:t="left";break;case i.MOUSE.RIGHT:t="right";break;case i.MOUSE.MIDDLE:t="middle"}return t},l.getOptions=function(){return l.options.rotationKey=l._parseToThingMouseKey(l.mouseButtons.PAN),l.options.zoomKey=l._parseToThingMouseKey(l.mouseButtons.ZOOM),l.options.moveKey=l._parseToThingMouseKey(l.mouseButtons.ORBIT),l.options.enableZoomOnTarget=l.enableZoomOnTarget,l.options},l.getPolarAngle=function(){return M.phi},l.getAzimuthalAngle=function(){return M.theta},l.getRotationSpherePhi=function(){return A.phi},l.getSphericalRadius=function(){return M.radius},l.saveState=function(){l.target0.copy(l.target),l.position0.copy(l.object.position),l.zoom0=l.object.zoom},l.reset=function(){l.target.copy(l.target0),l.object.position.copy(l.position0),l.object.zoom=l.zoom0,l.object.updateProjectionMatrix(),l.dispatchEvent({type:"change"}),l.update(),U=k},l.goHome=function(){W=!0,l.object.up.set(0,1,0),l.object.position.set(4890109.86328125,9295980.46875,13943610.3515625),A.phi=-.01,A.theta=Math.PI/2,A.radius=M.radius-l.radius,l._isCameraStatic=!1,l.update(),l._isCameraStatic=!0},l.setState=function(e){if(l.enabled){var t=l._getIntersectPoint();l.target.copy(t);var r=l.target,n=l.object.position,o=(new i.Vector3).subVectors(r,n),a=(new i.Vector3).crossVectors(n,o),s=(new i.Vector3).crossVectors(o,a);s=s.normalize(),l.object.up.copy(s),l.object.lookAt(r.x,r.y,r.z)}},l.correctUp=function(e){var t=e.time||3e3,r=e.callback,n=l.target,o=l.object.position,a=new i.Vector3;a.copy(l.object.up),a.normalize();var s=new i.Vector3;s.copy(o),s.normalize();var c=null;requestAnimationFrame((function e(o){c||(c=o);var i=o-c,l=a.lerp(s,i/t);this.object.up=l,this.object.lookAt(n),i/t<1?requestAnimationFrame(e):(r&&r(),console.log("end-correct"))}))},l._getIntersectPoint=function(e){if(void 0===e&&(e=!0),l._isCameraStatic||0===l._getState()||2===l._getState()||l._keepTarget)return l.target;var t=new i.Vector3,r=[];if(l.object.getWorldDirection(t),t.normalize(),I._camera=l.object,I.set(l.object.position,t),O.set(l.object.position,t),e){var n=s.a.get("nodeBuffer","tiles-root");if(n&&d.a.visible(n)&&(r=I.intersectObjects(n.children,!0)),r.length)return r[0].point}var o=new i.Vector3;return O.intersectSphere(_,o),o.equals(new i.Vector3(0,0,0))?l.target:o},l._getIntersectPointByMouse=function(e,t){var r=[];if(l.isEarth){var n=new i.Vector3;l.object.getWorldDirection(n),n.normalize(),O.set(l.object.position,n),I.setFromCamera(new i.Vector2(e,t),l.object);var o=s.a.get("nodeBuffer","tiles-root");o&&d.a.visible(o)&&(r=I.intersectObjects(o.children,!0));var a=new i.Vector3;return O.intersectSphere(_,a),r.length>0?r[0].point:l._getIntersectPoint()}var c=window.innerWidth*(Q.x+1)/2,u=(1-Q.y)*window.innerHeight/2,h=l.view.camera.screenToWorld(c,u);return new i.Vector3(h[0],h[1],h[2])},l._getIntersectQuaternion=function(e,t){var r=new i.Vector3;r.copy(e),r.normalize();var n=new i.Quaternion;n.setFromUnitVectors(new i.Vector3(0,1,0),r);var o=new i.Quaternion;return o.setFromAxisAngle(new i.Vector3(0,1,0),Math.PI/2+t),n.multiply(o),n.normalize(),n},l._correctCube=function(){var e=l._getIntersectPoint();R.position.copy(e),T.setFromVector3(e),T.radius=16378e3;var t=l._getIntersectQuaternion(e,T.theta);R.rotation.set(0,0,0),R.applyQuaternion(t),R.updateMatrixWorld(!0)},l._correctSphericalRotation=function(e){var t=new i.Vector3;if(t.copy(e),R.worldToLocal(t),A.setFromVector3(t),0!==l.target.length()){var r=l.object.position.distanceTo(l._getIntersectPoint());A.radius=r}return A.phi=-A.phi,A.theta=Math.PI+A.theta,!1},l._getAngle=function(){if(0!==l.target.length()){var e=new i.Vector3;e.copy(l.target),e.normalize();var t=new i.Vector3(0,l.radius,0);t.sub(l.object.position),t.normalize();var r=new i.Vector3;l.object.getWorldDirection(r),r.projectOnPlane(e),t.projectOnPlane(e);var n=t.angleTo(r);return r.cross(t),r.sub(e),r.length()<=1&&(n*=-1),n}},l.autoFixTarget=function(e){if(!H&&l.view&&(l.view.scene.add(R),R.visible=!1,H=!0),W){if(l.dispatchEvent({type:"change"}),l.enableDamping||(W=!1),Z.multiply(K),e.applyQuaternion(Z),l.object.updateMatrixWorld(!0),0!==l.target.length())(c=new i.Vector3).copy(e),c.normalize(),l.object.up.copy(c),l.target.applyQuaternion(Z);else{var t=l._getIntersectPoint();t.y+=100,l.target.copy(t)}l.object.lookAt(l.target)}else if(N){l.dispatchEvent({type:"change"}),N=!1;var r,n=l._getIntersectPoint();(r=new i.Vector3).copy(R.position),r.normalize();var o=new i.Vector3;o.setFromSpherical(A),o.applyMatrix4(R.matrixWorld),l.object.up.copy(r),l.object.position.copy(o),l.target.copy(n),l.object.lookAt(l.target)}else if(q||G){l.dispatchEvent({type:"change"});var a=l.object.position.distanceTo(l._getIntersectPoint());if(a>l.maxDistance&&G||a<l.minDistance&&q)A.radius=a,P=1;else{var s;s=q&&l.enableZoomOnTarget?l._getIntersectPointByMouse(Q.x,Q.y):l._getIntersectPointByMouse(0,0);var u=new i.Vector3;u.copy(l.object.position),u.sub(s),u.normalize();var h=M.radius*P-M.radius;A.radius+=h;var f=new i.Vector3;f.setFromSpherical(A),u.multiplyScalar(h),l.object.position.add(u),l._correctCube(),f.applyMatrix4(R.matrixWorld),l.object.position.copy(f),l.object.up.copy(l.object.position),l.target.copy(R.position),l.object.lookAt(l.target)}l.enableDamping||(q=!1,G=!1)}},l.addEventListener("start",(function(){l._isCameraStatic=!1})),l.addEventListener("end",(function(){l._isCameraStatic=!0})),l.update=function(){c=new i.Vector3;var e=l.object.position;c.copy(e),M.setFromVector3(c),T.setFromVector3(l.target),T.radius=l.radius,l.enabled&&l.autoFixTarget(e),l.object.lookAt(l.target),l._correctCube(),l._correctSphericalRotation(e);var t=l.object.position.distanceTo(l._getIntersectPoint());return l.rotateSpeed=t/3e7,l.zoomSpeed=A.radius/4e6*l.zoomFactor,l.mousePanSpeed=1,!0===l.enableDamping?W?(m.x*=1-l.dampingFactor,m.y*=1-l.dampingFactor,J(m.x),$(m.y),(N||q||G||m.x>-1e-10&&m.x<1e-10||m.y>-1e-10&&m.y<1e-10)&&(W=!1,m.set(0,0))):q?(P+=(1-P)*l.dampingZoomFactor)>.99999999&&(P=1,q=!1):G&&(P-=(P-1)*l.dampingZoomFactor)<1.0000001&&(P=1,G=!1):(m.set(0,0),P=1,W=!1,N=!1),Y.set(0,0,0),!1},l._getState=function(){return U},l.dispose=function(){l.domElement.removeEventListener("contextmenu",ge,!1),l.domElement.removeEventListener("mousedown",se,!1),l.domElement.removeEventListener("wheel",fe,!1),l.domElement.removeEventListener("touchstart",me,!1),l.domElement.removeEventListener("touchend",pe,!1),l.domElement.removeEventListener("touchmove",ve,!1),document.removeEventListener("mousemove",le,!1),document.removeEventListener("mouseup",ce,!1),window.removeEventListener("keydown",de,!1)},l.rotate=function(e,t){var r=t||1e3;switch(r=r/180*Math.PI,e){case"up":l.pan(0,r);break;case"down":l.pan(0,-r);break;case"left":l.pan(r,0);break;case"right":l.pan(-r,0)}},l.move=function(e,t){e=e/180*Math.PI,e*=l.rotateSpeed;var r=t/180*Math.PI;r*=l.rotateSpeed,Z.set(0,0,0,1),K.set(0,0,0,1),W=!0,J(e),$(r)},l.zoom=function(e,t){var r=t||.95;switch(r=Math.pow(r,l.zoomSpeed),e){case"in":oe(r);break;case"out":ne(r)}},l.earthRotate=function(e,t){var r=t||10;switch(r=r/180*Math.PI,r*=l.rotateSpeed,Z.set(0,0,0,1),K.set(0,0,0,1),W=!0,e){case"right":J(-r);break;case"left":J(r);break;case"up":$(r);break;case"down":$(-r)}},l.domElement.addEventListener("contextmenu",ge,!1),l.domElement.addEventListener("mousedown",se,!1),l.domElement.addEventListener("wheel",fe,!1),l.domElement.addEventListener("touchstart",me,!1),l.domElement.addEventListener("touchend",pe,!1),l.domElement.addEventListener("touchmove",ve,!1),window.addEventListener("keydown",de,!1),l.setLeftInteractive=function(e){l.mouseButtons=e?{ORBIT:0,ZOOM:1,PAN:2}:{ORBIT:2,ZOOM:1,PAN:0},l._leftInteractive=e},l.update(),l.pan=re,l.panDelta=f,l}return Object(a.a)(r,[{key:"leftInteractive",get:function(){return this._leftInteractive},set:function(e){this.setLeftInteractive(e)}},{key:"center",get:function(){return this.target}},{key:"noZoom",get:function(){return!this.enableZoom},set:function(e){this.enableZoom=!e}},{key:"noRotate",get:function(){return!this.enableRotate},set:function(e){this.enableRotate=!e}},{key:"noPan",get:function(){return!this.enablePan},set:function(e){this.enablePan=!e}},{key:"noKeys",get:function(){return!this.enableKeys},set:function(e){this.enableKeys=!e}},{key:"staticMoving",get:function(){return!this.enableDamping},set:function(e){this.enableDamping=!e}},{key:"dynamicDampingFactor",get:function(){return this.dampingFactor},set:function(e){this.dampingFactor=e}},{key:"minPolarAngle",get:function(){return this._minPolarAngle},set:function(e){this._minPolarAngle=e}},{key:"maxPolarAngle",get:function(){return this._maxPolarAngle},set:function(e){this._maxPolarAngle=e<this.maxPitchAngle*Math.PI/180?e:this.maxPitchAngle*Math.PI/180}}]),r}(i.EventDispatcher),g=r(438),y=function(){function e(t){Object(o.a)(this,e),s.a.init(),this.alias=1,this.mouse=new i.Vector2,this.raycaster=new i.Raycaster,Object.assign(this,t),this.init()}return Object(a.a)(e,[{key:"init",value:function(){this.objectManager=new Map,"string"===typeof this.el&&(this.el=document.getElementById(this.el)),this.domElement=this.el;var e=this.getSize(),t=e.width,r=e.height;this.width=t,this.height=r,this.renderCamera=new u(this.width,this.height,45,.1,1e4,-1e4,1e4),this.renderCamera.setSize(this.width,this.height),this.renderer||(this.canvas=document.createElement("canvas"),this.context=this.canvas.getContext("webgl2",{preserveDrawingBuffer:!1,antialias:!0,alpha:!0}),this.renderer=new i.WebGLRenderer({canvas:this.canvas,context:this.context,logarithmicDepthBuffer:!0}),this.renderer.info.autoReset=!1,this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(this.width,this.height),this.renderer.autoClear=!1,this.renderer.sortObjects=!0,this.renderer.shadowMap.enabled=!0,this.renderer.shadowMap.type=i.PCFSoftShadowMap,this.domElement.appendChild(this.renderer.domElement)),this.scene=new i.Scene,this.scene.background=new i.Color(0,0,0),this.node=new i.Group,this.scene.add(this.node),this.curOrbit=new p(this,this.renderCamera,this.domElement),this.curOrbit.enableDamping=!0,this._camera=new f({camera:this.renderCamera,control:this.curOrbit,el:this.domElement}),this.textureLoader=new i.TextureLoader,this.camera=new m({camera:this._camera,picker:{},onAfterUpdate:function(){}}),this.CSSRender=new g.b,this.CSSRender.setSize(this.width,this.height),this.CSSRender.domElement.style.position="absolute",this.CSSRender.domElement.style.top=0,this.domElement.appendChild(this.CSSRender.domElement),this.initLight(),this.initEffect(),this.initEvent(),this.tick=this.tick.bind(this),this.renderer.setAnimationLoop(this.tick)}},{key:"initEvent",value:function(){this.curOrbit.addEventListener("change",(function(e){})),this.handleResize=this.handleResize.bind(this),window.addEventListener("resize",this.handleResize,!1),this.handleClick=this.handleClick.bind(this),this.domElement.addEventListener("click",this.handleClick,!1)}},{key:"handleResize",value:function(e){e.preventDefault(),this.resize()}},{key:"handleClick",value:function(e){e.preventDefault(),this.onBeforeSelect(e);var t=e.clientX,r=e.clientY,o=e.changedTouches,a=t,i=r;if(o){var s=Object(n.a)(o,1)[0];s&&(i=s.pageX,i=s.pageY)}this.mouse.x=a/this.domElement.offsetWidth*2-1,this.mouse.y=-i/this.domElement.offsetHeight*2+1,this.raycaster.setFromCamera(this.mouse,this.rendererCamera);var l=this.raycaster.intersectObject(this.scene,!0),c=null;l&&l.length>0&&(c=l[0].object,this.onSelect(e,c)),this.onAfterSelect(e,c)}},{key:"onBeforeSelect",value:function(e){}},{key:"onSelect",value:function(e,t){}},{key:"onAfterSelect",value:function(e,t){}},{key:"initBox",value:function(){var e=new i.CubeTextureLoader;e.setPath("images/cube/2/");var t=e.load(["negx.jpg","posy.jpg","negy.jpg","posz.jpg","negz.jpg"]);this.scene.background=t}},{key:"initLight",value:function(){var e=new i.DirectionalLight;e.position.x=0,e.position.y=1e3,e.position.z=0,this.scene.add(e),(e=new i.DirectionalLight).position.x=1e3,e.position.y=0,e.position.z=0,this.scene.add(e),(e=new i.DirectionalLight).position.x=0,e.position.y=0,e.position.z=1e3,this.scene.add(e)}},{key:"initEffect",value:function(){this.compositorRender=new window.THREEx.EffectManager(this.renderer,this.scene,this.renderCamera,this.alias)}},{key:"getSize",value:function(){return{width:this.domElement.offsetWidth,height:this.domElement.offsetHeight}}},{key:"resize",value:function(){var e=this.getSize(),t=e.width,r=e.height;this.renderCamera.setSize(t,r),this.renderCamera.aspect=t/r,this.renderCamera.updateProjectionMatrix(),this.renderer.setSize(t,r),this.CSSRender.setSize(t,r),this.compositorRender.update()}},{key:"addMap",value:function(e){if(!this.map){var t=r(768).default;e.view=this,e.node=new i.Group,e.uid=i.Math.generateUUID(),this.node.add(e.node),this.map=new t(e),this.objectManager.set(this.map.uid,this.map)}return this.map}},{key:"setMap",value:function(e){this.map?this.map.setMap(e):this.addMap(e)}},{key:"setStyle",value:function(e){this.map.setStyle(e)}},{key:"addLayer",value:function(e){var t=r(754)("./".concat(e.type)).default;e.view=this,e.node=new i.Group,e.uid=i.Math.generateUUID(),this.node.add(e.node);var n=new t(e);return this.objectManager.set(n.uid,n),n}},{key:"tick",value:function(){this.compositorRender.update(),this.compositorRender.render(this.renderer,this.scene,this.renderCamera),this.objectManager.forEach((function(e){e&&e.update&&e.update()})),this.camera.update&&this.camera.update(),this.CSSRender.render(this.scene,this.renderCamera),this.update()}},{key:"update",value:function(){}},{key:"destory",value:function(){this.domElement.removeEventListener("click",this.handleClick),this.renderer.setAnimationLoop(null)}}]),e}();t.default=y}}]);
//# sourceMappingURL=7.cec972f1.chunk.js.map